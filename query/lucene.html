<!DOCTYPE html>
<!--
 | Generated by Apache Maven Doxia Site Renderer 1.7.4 at 2018-02-04 
 | Rendered using Apache Maven Fluido Skin 1.6
-->
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="Date-Revision-yyyymmdd" content="20180204" />
    <meta http-equiv="Content-Language" content="en" />
    <title>Jackrabbit Oak &#x2013; Lucene Index</title>
    <link rel="stylesheet" href="../css/apache-maven-fluido-1.6.min.css" />
    <link rel="stylesheet" href="../css/site.css" />
    <link rel="stylesheet" href="../css/print.css" media="print" />
      <script type="text/javascript" src="../js/apache-maven-fluido-1.6.min.js"></script>
      </head>
    <body class="topBarEnabled">
                  <a href="https://github.com/apache/jackrabbit-oak">
      <img style="position: absolute; top: 0; right: 0; border: 0; z-index: 10000;"
        src="https://s3.amazonaws.com/github/ribbons/forkme_right_red_aa0000.png"
        alt="Fork me on GitHub">
    </a>
      <div id="topbar" class="navbar navbar-fixed-top ">
      <div class="navbar-inner">
        <div class="container-fluid">
        <a data-target=".nav-collapse" data-toggle="collapse" class="btn btn-navbar">
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
        </a>
<a class="brand" href="../"  title="Oak logo"><img src="../oak_logo.png" alt="Oak logo" />
</a>
            <ul class="nav">
        <li class="dropdown">
        <a href="#" class="dropdown-toggle" data-toggle="dropdown">Overview <b class="caret"></b></a>
        <ul class="dropdown-menu">
            <li><a href="../index.html" title="Jackrabbit Oak">Jackrabbit Oak</a></li>
            <li><a href="../license.html" title="License">License</a></li>
            <li><a href="../downloads.html" title="Downloads">Downloads</a></li>
            <li><a href="../articles.html" title="Articles">Articles</a></li>
        </ul>
      </li>
        <li class="dropdown">
        <a href="#" class="dropdown-toggle" data-toggle="dropdown">Concepts and Architecture <b class="caret"></b></a>
        <ul class="dropdown-menu">
            <li><a href="../architecture/overview.html" title="Overview">Overview</a></li>
            <li><a href="../architecture/nodestate.html" title="The Node State Model">The Node State Model</a></li>
        </ul>
      </li>
        <li class="dropdown">
        <a href="#" class="dropdown-toggle" data-toggle="dropdown">Main APIs <b class="caret"></b></a>
        <ul class="dropdown-menu">
            <li><a href="http://www.day.com/specs/jcr/2.0/index.html" title="JCR API">JCR API</a></li>
            <li><a href="../oak_api/overview.html" title="Oak API">Oak API</a></li>
        </ul>
      </li>
        <li class="dropdown">
        <a href="#" class="dropdown-toggle" data-toggle="dropdown">Features and Plugins <b class="caret"></b></a>
        <ul class="dropdown-menu">
            <li class="dropdown-submenu">
<a href="../nodestore/overview.html" title="Node Storage">Node Storage</a>
              <ul class="dropdown-menu">
                  <li><a href="../nodestore/documentmk.html" title="Document NodeStore">Document NodeStore</a></li>
                  <li><a href="../nodestore/segment/overview.html" title="Segment NodeStore">Segment NodeStore</a></li>
                  <li><a href="../nodestore/compositens.html" title="Composite NodeStore">Composite NodeStore</a></li>
              </ul>
            </li>
            <li><a href="../plugins/blobstore.html" title="Blob Storage">Blob Storage</a></li>
            <li class="dropdown-submenu">
<a href="../query/query.html" title="Query">Query</a>
              <ul class="dropdown-menu">
                  <li><a href="../query/query-engine.html" title="Query Engine">Query Engine</a></li>
                  <li><a href="../query/grammar-xpath.html" title="XPath Grammar">XPath Grammar</a></li>
                  <li><a href="../query/grammar-sql2.html" title="SQL-2 Grammar">SQL-2 Grammar</a></li>
                  <li><a href="../query/query-troubleshooting.html" title="Troubleshooting">Troubleshooting</a></li>
                  <li><a href="../query/indexing.html" title="Indexing">Indexing</a></li>
                  <li><a href="../query/lucene.html" title="Lucene Index">Lucene Index</a></li>
                  <li><a href="../query/property-index.html" title="Property Index">Property Index</a></li>
                  <li><a href="../query/solr.html" title="Solr Index">Solr Index</a></li>
              </ul>
            </li>
            <li><a href="../security/overview.html" title="Security">Security</a></li>
            <li><a href="../features/atomic-counter.html" title="Atomic Counter">Atomic Counter</a></li>
            <li><a href="../features/observation.html" title="Observation">Observation</a></li>
        </ul>
      </li>
        <li class="dropdown">
        <a href="#" class="dropdown-toggle" data-toggle="dropdown">Using Oak <b class="caret"></b></a>
        <ul class="dropdown-menu">
            <li><a href="../use_getting_started.html" title="Getting Started">Getting Started</a></li>
            <li><a href="../construct.html" title="Repository Construction">Repository Construction</a></li>
            <li><a href="../osgi_config.html" title="Configuring Oak">Configuring Oak</a></li>
            <li><a href="../command_line.html" title="Command Line Tools">Command Line Tools</a></li>
            <li><a href="../migration.html" title="Migration">Migration</a></li>
            <li><a href="../differences.html" title="Differences to Jackrabbit 2">Differences to Jackrabbit 2</a></li>
            <li><a href="../known_issues.html" title="Known Issues">Known Issues</a></li>
            <li><a href="../constraints.html" title="Constraints">Constraints</a></li>
            <li><a href="../dos_and_donts.html" title="Dos and Don'ts">Dos and Don'ts</a></li>
            <li><a href="../coldstandby/coldstandby.html" title="Cold Standby">Cold Standby</a></li>
            <li><a href="../FAQ.html" title="FAQ">FAQ</a></li>
        </ul>
      </li>
        <li class="dropdown">
        <a href="#" class="dropdown-toggle" data-toggle="dropdown">Developing Oak <b class="caret"></b></a>
        <ul class="dropdown-menu">
            <li><a href="../dev_getting_started.html" title="Getting Started">Getting Started</a></li>
            <li><a href="../participating.html" title="Participating">Participating</a></li>
            <li><a href="../developing-with-git.html" title="Developing with Git">Developing with Git</a></li>
            <li><a href="../diagnostic-builds.html" title="Cutting diagnostic builds">Cutting diagnostic builds</a></li>
            <li><a href="../branching.html" title="Branching off a new stable">Branching off a new stable</a></li>
            <li><a href="../attribution.html" title="Attribution">Attribution</a></li>
            <li><a href="../release-schedule.html" title="Release Schedule">Release Schedule</a></li>
        </ul>
      </li>
        <li class="dropdown">
        <a href="#" class="dropdown-toggle" data-toggle="dropdown">Links <b class="caret"></b></a>
        <ul class="dropdown-menu">
            <li><a href="http://jackrabbit.apache.org/oak" title="Apache Jackrabbit Oak">Apache Jackrabbit Oak</a></li>
            <li><a href="http://jackrabbit.apache.org/" title="Apache Jackrabbit">Apache Jackrabbit</a></li>
        </ul>
      </li>
              </ul>
            </div>
        </div>
      </div>
    </div>
    <div class="container-fluid">
      <div id="banner">
        <div class="pull-left"><div id="bannerLeft"><h2>Oak Documentation</h2>
</div>
</div>
        <div class="pull-right"></div>
        <div class="clear"><hr/></div>
      </div>

      <div id="breadcrumbs">
        <ul class="breadcrumb">
        <li id="publishDate">Last Published: 2018-02-04<span class="divider">|</span>
</li>
          <li id="projectVersion">Version: 1.10-SNAPSHOT</li>
        </ul>
      </div>
      <div class="row-fluid">
        <div id="leftColumn" class="span2">
          <div class="well sidebar-nav">
<ul class="nav nav-list">
          <li class="nav-header">Overview</li>
    <li><a href="../index.html" title="Jackrabbit Oak"><span class="none"></span>Jackrabbit Oak</a>  </li>
    <li><a href="../license.html" title="License"><span class="none"></span>License</a>  </li>
    <li><a href="../downloads.html" title="Downloads"><span class="none"></span>Downloads</a>  </li>
    <li><a href="../articles.html" title="Articles"><span class="none"></span>Articles</a>  </li>
          <li class="nav-header">Concepts and Architecture</li>
    <li><a href="../architecture/overview.html" title="Overview"><span class="none"></span>Overview</a>  </li>
    <li><a href="../architecture/nodestate.html" title="The Node State Model"><span class="none"></span>The Node State Model</a>  </li>
          <li class="nav-header">Main APIs</li>
    <li><a href="http://www.day.com/specs/jcr/2.0/index.html" class="externalLink" title="JCR API"><span class="none"></span>JCR API</a>  </li>
    <li><a href="../oak_api/overview.html" title="Oak API"><span class="none"></span>Oak API</a>  </li>
          <li class="nav-header">Features and Plugins</li>
    <li><a href="../nodestore/overview.html" title="Node Storage"><span class="icon-chevron-down"></span>Node Storage</a>
      <ul class="nav nav-list">
    <li><a href="../nodestore/documentmk.html" title="Document NodeStore"><span class="icon-chevron-down"></span>Document NodeStore</a>
      <ul class="nav nav-list">
    <li><a href="../nodestore/document/node-bundling.html" title="Node Bundling"><span class="none"></span>Node Bundling</a>  </li>
    <li><a href="../nodestore/document/secondary-store.html" title="Secondary Store"><span class="none"></span>Secondary Store</a>  </li>
    <li><a href="../nodestore/persistent-cache.html" title="Persistent Cache"><span class="none"></span>Persistent Cache</a>  </li>
    <li><a href="../clustering.html" title="Clustering"><span class="none"></span>Clustering</a>  </li>
      </ul>
  </li>
    <li><a href="../nodestore/segment/overview.html" title="Segment NodeStore"><span class="none"></span>Segment NodeStore</a>  </li>
    <li><a href="../nodestore/compositens.html" title="Composite NodeStore"><span class="none"></span>Composite NodeStore</a>  </li>
      </ul>
  </li>
    <li><a href="../plugins/blobstore.html" title="Blob Storage"><span class="none"></span>Blob Storage</a>  </li>
    <li><a href="../query/query.html" title="Query"><span class="icon-chevron-down"></span>Query</a>
      <ul class="nav nav-list">
    <li><a href="../query/query-engine.html" title="Query Engine"><span class="none"></span>Query Engine</a>  </li>
    <li><a href="../query/grammar-xpath.html" title="XPath Grammar"><span class="none"></span>XPath Grammar</a>  </li>
    <li><a href="../query/grammar-sql2.html" title="SQL-2 Grammar"><span class="none"></span>SQL-2 Grammar</a>  </li>
    <li><a href="../query/query-troubleshooting.html" title="Troubleshooting"><span class="none"></span>Troubleshooting</a>  </li>
    <li><a href="../query/indexing.html" title="Indexing"><span class="none"></span>Indexing</a>  </li>
    <li class="active"><a href="#"><span class="none"></span>Lucene Index</a>
  </li>
    <li><a href="../query/property-index.html" title="Property Index"><span class="none"></span>Property Index</a>  </li>
    <li><a href="../query/solr.html" title="Solr Index"><span class="none"></span>Solr Index</a>  </li>
      </ul>
  </li>
    <li><a href="../security/overview.html" title="Security"><span class="none"></span>Security</a>  </li>
    <li><a href="../features/atomic-counter.html" title="Atomic Counter"><span class="none"></span>Atomic Counter</a>  </li>
    <li><a href="../features/observation.html" title="Observation"><span class="none"></span>Observation</a>  </li>
          <li class="nav-header">Using Oak</li>
    <li><a href="../use_getting_started.html" title="Getting Started"><span class="none"></span>Getting Started</a>  </li>
    <li><a href="../construct.html" title="Repository Construction"><span class="none"></span>Repository Construction</a>  </li>
    <li><a href="../osgi_config.html" title="Configuring Oak"><span class="none"></span>Configuring Oak</a>  </li>
    <li><a href="../command_line.html" title="Command Line Tools"><span class="none"></span>Command Line Tools</a>  </li>
    <li><a href="../migration.html" title="Migration"><span class="none"></span>Migration</a>  </li>
    <li><a href="../differences.html" title="Differences to Jackrabbit 2"><span class="none"></span>Differences to Jackrabbit 2</a>  </li>
    <li><a href="../known_issues.html" title="Known Issues"><span class="none"></span>Known Issues</a>  </li>
    <li><a href="../constraints.html" title="Constraints"><span class="none"></span>Constraints</a>  </li>
    <li><a href="../dos_and_donts.html" title="Dos and Don'ts"><span class="none"></span>Dos and Don'ts</a>  </li>
    <li><a href="../coldstandby/coldstandby.html" title="Cold Standby"><span class="none"></span>Cold Standby</a>  </li>
    <li><a href="../FAQ.html" title="FAQ"><span class="none"></span>FAQ</a>  </li>
          <li class="nav-header">Developing Oak</li>
    <li><a href="../dev_getting_started.html" title="Getting Started"><span class="none"></span>Getting Started</a>  </li>
    <li><a href="../participating.html" title="Participating"><span class="none"></span>Participating</a>  </li>
    <li><a href="../developing-with-git.html" title="Developing with Git"><span class="none"></span>Developing with Git</a>  </li>
    <li><a href="../diagnostic-builds.html" title="Cutting diagnostic builds"><span class="none"></span>Cutting diagnostic builds</a>  </li>
    <li><a href="../branching.html" title="Branching off a new stable"><span class="none"></span>Branching off a new stable</a>  </li>
    <li><a href="../attribution.html" title="Attribution"><span class="none"></span>Attribution</a>  </li>
    <li><a href="../release-schedule.html" title="Release Schedule"><span class="none"></span>Release Schedule</a>  </li>
          <li class="nav-header">Links</li>
    <li><a href="http://jackrabbit.apache.org/oak" class="externalLink" title="Apache Jackrabbit Oak"><span class="none"></span>Apache Jackrabbit Oak</a>  </li>
    <li><a href="http://jackrabbit.apache.org/" class="externalLink" title="Apache Jackrabbit"><span class="none"></span>Apache Jackrabbit</a>  </li>
  </ul>
          <hr />
          <div id="poweredBy">
          <script type="text/javascript">asyncJs( 'https://apis.google.com/js/plusone.js' )</script>
        <div class="g-plusone" data-href="http://jackrabbit.apache.org/oak/docs/" data-size="tall" ></div>
                  <div class="clear"></div>
              <div class="clear"></div>
              <div class="clear"></div>
              <div class="clear"></div>
  <a href="http://maven.apache.org/" title="Built by Maven" class="poweredBy"><img class="builtBy" alt="Built by Maven" src="../images/logos/maven-feather.png" /></a>
              </div>
          </div>
        </div>
        <div id="bodyColumn"  class="span10" >
<!--
   Licensed to the Apache Software Foundation (ASF) under one or more
   contributor license agreements.  See the NOTICE file distributed with
   this work for additional information regarding copyright ownership.
   The ASF licenses this file to You under the Apache License, Version 2.0
   (the "License"); you may not use this file except in compliance with
   the License.  You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.
  --><div class="section">
<h2><a name="Lucene_Index"></a>Lucene Index</h2>

<ul>
  
<li><a href="#new-1.6">New in 1.6</a></li>
  
<li><a href="#index-definition">Index Definition</a>
  
<ul>
    
<li><a href="#indexing-rules">Indexing Rules</a>
    
<ul>
      
<li><a href="#cost-overrides">Cost Overrides</a></li>
      
<li><a href="#indexing-rule-inheritence">Indexing Rule inheritance</a></li>
      
<li><a href="#property-definitions">Property Definitions</a></li>
      
<li><a href="#path-restrictions">Evaluate Path Restrictions</a></li>
      
<li><a href="#include-exclude">Include and Exclude paths from indexing</a></li>
    </ul></li>
    
<li><a href="#aggregation">Aggregation</a></li>
    
<li><a href="#analyzers">Analyzers</a>
    
<ul>
      
<li><a href="#analyzer-classes">Specify analyzer class directly</a></li>
      
<li><a href="#analyzer-composition">Create analyzer via composition</a></li>
    </ul></li>
    
<li><a href="#codec">Codec</a></li>
    
<li><a href="#boost">Boost and Search Relevancy</a></li>
    
<li><a href="#stored-index-definition">Effective Index Definition</a></li>
    
<li><a href="#generate-index-definition">Generating Index Definition</a></li>
  </ul></li>
  
<li><a href="#nrt-indexing">Near Real Time Indexing</a></li>
  
<li><a href="#osgi-config">LuceneIndexProvider Configuration</a></li>
  
<li><a href="#tika-config">Tika Config</a>
  
<ul>
    
<li><a href="#mime-type-usage">Mime type usage</a></li>
    
<li><a href="#mime-type-mapping">Mime type mapping</a></li>
  </ul></li>
  
<li><a href="#non-root-index">Non Root Index Definitions</a></li>
  
<li><a href="#native-query">Native Query and Index Selection</a></li>
  
<li><a href="#copy-on-read">CopyOnRead</a></li>
  
<li><a href="#copy-on-write">CopyOnWrite</a></li>
  
<li><a href="#mbeans">Lucene Index MBeans</a></li>
  
<li><a href="#active-blob-collection">Active Index Files Collection</a></li>
  
<li><a href="#luke">Analyzing created Lucene Index</a></li>
  
<li><a href="#text-extraction">Pre-Extracting Text from Binaries</a></li>
  
<li><a href="#advanced-search-features">Advanced search features</a>
  
<ul>
    
<li><a href="#suggestions">Suggestions</a></li>
    
<li><a href="#spellchecking">Spellchecking</a></li>
    
<li><a href="#facets">Facets</a></li>
    
<li><a href="#score-explanation">Score Explanation</a></li>
    
<li><a href="#custom-hooks">Custom hooks</a></li>
  </ul></li>
  
<li><a href="#design-considerations">Design Considerations</a></li>
  
<li><a href="#limits">Limits</a></li>
  
<li><a href="#lucene-vs-property">Lucene Index vs Property Index</a></li>
  
<li><a href="#examples">Examples</a>
  
<ul>
    
<li><a href="#simple-queries">A - Simple queries</a></li>
    
<li><a href="#queries-structured-content">B - Queries for structured content</a>
    
<ul>
      
<li><a href="#uc1">UC1 - Find all assets which are having <tt>status</tt> as <tt>published</tt></a></li>
      
<li><a href="#uc2">UC2 - Find all assets which are having <tt>status</tt> as <tt>published</tt> sorted by last modified date</a></li>
      
<li><a href="#uc3">UC3 - Find all assets where comment contains <i>december</i></a></li>
      
<li><a href="#uc4">UC4 - Find all assets which are created by David and refer to december</a></li>
    </ul></li>
  </ul></li>
</ul>
<p>Oak supports Lucene based indexes to support both property constraint and full text constraints. Depending on the configuration a Lucene index can be used to evaluate property constraints, full text constraints, path restrictions and sorting.</p>

<div class="source">
<div class="source"><pre class="prettyprint">SELECT * FROM [nt:base] WHERE [assetType] = 'image'
</pre></div></div>
<p>Following index definition would allow using Lucene index for above query</p>

<div class="source">
<div class="source"><pre class="prettyprint">/oak:index/assetType
  - jcr:primaryType = &quot;oak:QueryIndexDefinition&quot;
  - compatVersion = 2
  - type = &quot;lucene&quot;
  - async = &quot;async&quot;
  + indexRules
    - jcr:primaryType = &quot;nt:unstructured&quot;
    + nt:base
      + properties
        - jcr:primaryType = &quot;nt:unstructured&quot;
        + assetType
          - propertyIndex = true
          - name = &quot;assetType&quot;
</pre></div></div>
<p>The index definition node for a lucene-based index</p>

<ul>
  
<li>must be of type <tt>oak:QueryIndexDefinition</tt></li>
  
<li>must have the <tt>type</tt> property set to <b><tt>lucene</tt></b></li>
  
<li>must contain the <tt>async</tt> property set to the value <tt>async</tt>, this is what  sends the index update process to a background thread</li>
</ul>
<p><i>Note that compared to <a href="query.html#property-index">Property Index</a> Lucene Property Index is always configured in Async mode hence it might lag behind in reflecting the current repository state while performing the query</i></p>
<p>Taking another example. To support following query</p>

<div class="source">
<div class="source"><pre class="prettyprint">//*[jcr:contains(., 'text')]
</pre></div></div>
<p>The Lucene index needs to be configured to index all properties</p>

<div class="source">
<div class="source"><pre class="prettyprint">/oak:index/assetType
  - jcr:primaryType = &quot;oak:QueryIndexDefinition&quot;
  - compatVersion = 2
  - type = &quot;lucene&quot;
  - async = &quot;async&quot;
  + indexRules
    - jcr:primaryType = &quot;nt:unstructured&quot;
    + nt:base
      + properties
        - jcr:primaryType = &quot;nt:unstructured&quot;
        + allProps
          - name = &quot;.*&quot;
          - isRegexp = true
          - nodeScopeIndex = true
</pre></div></div>
<div class="section">
<h3><a name="New_in_1.6"></a><a name="new-1.6"></a> New in 1.6</h3>
<p>Following are the new features in 1.6 release</p>

<ul>
  
<li><a href="#nrt-indexing">Near Real Time Indexing</a></li>
  
<li><a href="#stored-index-definition">Effective Index Definition</a></li>
</ul></div>
<div class="section">
<h3><a name="Index_Definition"></a><a name="index-definition"></a> Index Definition</h3>
<p>Lucene index definition consist of <tt>indexingRules</tt>, <tt>analyzers</tt> , <tt>aggregates</tt> etc which determine which node and properties are to be indexed and how they are indexed.</p>
<p>Below is the canonical index definition structure</p>

<div class="source">
<div class="source"><pre class="prettyprint">luceneIndex (oak:QueryIndexDefinition)
  - type (string) = 'lucene' mandatory
  - async (string) = 'async' mandatory
  - blobSize (long) = 32768
  - maxFieldLength (long) = 10000
  - evaluatePathRestrictions (boolean) = false
  - name (string)
  - compatVersion (long) = 2
  - includedPaths (string) multiple
  - excludedPaths (string) multiple
  - queryPaths (string) multiple = ['/']
  - indexPath (string)
  - codec (string)
  - refresh (boolean)
  + indexRules (nt:unstructured)
  + aggregates (nt:unstructured)
  + analyzers (nt:unstructured)
  + tika (nt:unstructured)
</pre></div></div>
<p>Following are the config options which can be defined at the index definition level</p>

<dl>
<dt>type</dt>
<dd>Required and should always be <tt>lucene</tt></dd>
<dt>async</dt>
<dd>Required and should always be <tt>async</tt></dd>
<dt><a class="externalLink" href="https://issues.apache.org/jira/browse/OAK-2201">blobSize</a></dt>
<dd>Default value 32768 (32kb)</dd>
<dd>Size in bytes used for splitting the index files when storing them in NodeStore</dd>
<dt>functionName</dt>
<dd>Name to be used to enable index usage with <a href="#native-query">native query support</a></dd>
<dt>evaluatePathRestrictions</dt>
<dd>Optional boolean property defaults to <tt>false</tt></dd>
<dd>If enabled the index can evaluate <a href="#path-restrictions">path restrictions</a></dd>
<dt>includedPaths</dt>
<dd>Optional multi value property. Defaults to &#x2018;/&#x2019;</dd>
<dd>List of paths which should be <a href="#include-exclude">included</a> in indexing.</dd>
<dt>excludedPaths</dt>
<dd>Optional multi value property. Defaults to empty</dd>
<dd>List of paths which should be <a href="#include-exclude">excluded</a> from indexing.</dd>
<dt>queryPaths</dt>
<dd>Optional multi value property. Defaults to &#x2018;/&#x2019;</dd>
<dd>List of paths for which the index can be used to perform queries. Refer to <a href="#include-exclude">Path Includes/Excludes</a> for more details</dd>
<dt>indexPath</dt>
<dd>Optional string property to specify <a href="#copy-on-write">index path</a></dd>
<dd>Path of the index definition in the repository. For e.g. if the index  definition is specified at <tt>/oak:index/lucene</tt> then set this path in <tt>indexPath</tt></dd>
<dt>codec</dt>
<dd>Optional string property</dd>
<dd>Name of the <a href="#codec">Lucene codec</a> to use</dd>
<dt>name</dt>
<dd>Optional property</dd>
<dd>Captures the name of the index which is used while logging</dd>
<dt>compatVersion</dt>
<dd>Required integer property and should be set to 2</dd>
<dd>By default Oak uses older Lucene index implementation which does not  supports property restrictions, index time aggregation etc.  To make use of this feature set it to 2.  Please note for full text indexing with compatVersion 2,  at query time, only the access right of the parent (aggregate) node is checked,  and the access right of the child nodes is not checked.  If this is a security concern, then compatVersion should not be set,  so that query time aggregation is used, in which case the access right  of the relevant child is also checked.  A compatVersion 2 full text index is usually faster to run queries.</dd>
<dt><a class="externalLink" href="https://issues.apache.org/jira/browse/OAK-2469">maxFieldLength</a></dt>
<dd>Numbers of terms indexed per field. Defaults to 10000</dd>
<dt>refresh</dt>
<dd>Optional boolean property</dd>
<dd>Used to refresh the stored index definition. See <a href="#stored-index-definition">Effective Index Definition</a></dd>
</dl>
<div class="section">
<h4><a name="Indexing_Rules"></a><a name="indexing-rules"></a> Indexing Rules</h4>
<p>Indexing rules defines which types of node and properties are indexed. An index configuration can define one or more <tt>indexingRules</tt> for different nodeTypes.</p>

<div class="source">
<div class="source"><pre class="prettyprint">fulltextIndex
  - jcr:primaryType = &quot;oak:QueryIndexDefinition&quot;
  - compatVersion = 2
  - type = &quot;lucene&quot;
  - async = &quot;async&quot;
  + indexRules
    - jcr:primaryType = &quot;nt:unstructured&quot;
    + app:Page
      + properties
        - jcr:primaryType = &quot;nt:unstructured&quot;
        + publishedDate
          - propertyIndex = true
          - name = &quot;jcr:content/publishedDate&quot;
    + app:Asset
      + properties
        - jcr:primaryType = &quot;nt:unstructured&quot;
        + imageType
          - propertyIndex = true
          - name = &quot;jcr:content/metadata/imageType&quot;
</pre></div></div>
<p>Rules are defined per nodeType and each rule has one or more property definitions determine which properties are indexed. Below is the canonical index definition structure</p>

<div class="source">
<div class="source"><pre class="prettyprint">ruleName (nt:unstructured)
  - inherited (boolean) = true
  - indexNodeName (boolean) = false
  - includePropertyTypes (string) multiple
  + properties (nt:unstructured)
</pre></div></div>
<p>Following are the config options which can be defined at the index rule level</p>

<dl>
<dt>inherited</dt>
<dd>Optional boolean property defaults to true</dd>
<dd>Determines if the rule is applicable on exact match or can be applied if  match is done on basis of nodeType inheritance</dd>
<dt>includePropertyTypes</dt>
<dd>Applicable when index is enabled for fulltext indexing</dd>
<dd>For full text index defaults to include all types</dd>
<dd>String array of property types which should be indexed. The values can be one  specified in <a class="externalLink" href="http://www.day.com/specs/jsr170/javadocs/jcr-2.0/constant-values.html#javax.jcr.PropertyType.TYPENAME_STRING">PropertyType Names</a></dd>
<dt><a name="index-node-name"></a><br />indexNodeName</dt>
<dd><tt>@since Oak 1.0.20, 1.2.5</tt></dd>
<dd>Default to false. If set to true then index would also be created for node name.  This would enable faster evaluation of queries involving constraints on Node  name. For example
  
<ul>
    
<li><i>select [jcr:path] from [nt:base] where NAME() = &#x2018;kite&#x2019;</i></li>
    
<li><i>select [jcr:path] from [nt:base] where NAME() LIKE &#x2018;kite%&#x2019;</i></li>
    
<li>//kite</li>
    
<li>//*[jcr:like(fn:name(), &#x2018;kite%&#x2019;)]</li>
    
<li>//element(*, app:Asset)[fn:name() = &#x2018;kite&#x2019;]</li>
    
<li>//element(kite, app:Asset)</li>
  </ul></dd>
</dl>
<div class="section">
<h5><a name="Cost_Overrides"></a><a name="cost-overrides"></a> Cost Overrides</h5>
<p>By default, the cost of using this index is calculated follows: For each query, the overhead is one operation. For each entry in the index, the cost is one. The following only applies to <tt>compatVersion</tt> 2 only: To use use a lower or higher cost, you can set the following optional properties in the index definition:</p>

<div class="source">
<div class="source"><pre class="prettyprint">- costPerExecution (Double) = 1.0
- costPerEntry (Double) = 1.0
</pre></div></div>
<p>Please note that typically, those settings don&#x2019;t need to be explicitly set. Cost per execution is the overhead of one query. Cost per entry is the cost per node in the index. Using 0.5 means the cost is half, which means the index would be used used more often (that is, even if there is a different index with similar cost).</p></div>
<div class="section">
<h5><a name="Indexing_Rule_inheritance"></a><a name="indexing-rule-inheritence"></a>Indexing Rule inheritance</h5>
<p><tt>indexRules</tt> are defined per nodeType and support nodeType inheritance. For example while indexing any node the indexer would lookup for applicable indexRule for that node based on its <i>primaryType</i>. If a direct match is found then that rule would be used otherwise it would look for rule for any of the parent types. The rules are looked up in the order of there entry under <tt>indexRules</tt> node (indexRule node itself is of type <tt>nt:unstructured</tt> which has <tt>orderable</tt> child nodes)</p>
<p>If <tt>inherited</tt> is set to false on any rule then that rule would only be applicable if exact match is found</p></div>
<div class="section">
<h5><a name="Property_Definitions"></a><a name="property-definitions"></a>Property Definitions</h5>
<p>Each index rule consist of one ore more property definition defined under <tt>properties</tt>. Order of property definition node is important as some properties are based on regular expressions. Below is the canonical property definition structure</p>

<div class="source">
<div class="source"><pre class="prettyprint">propNode (nt:unstructured)
  - name (string)
  - boost (double) = '1.0'
  - index (boolean) = true
  - useInExcerpt (boolean) = false
  - analyzed (boolean) = false
  - nodeScopeIndex (boolean) = false
  - ordered (boolean) = false
  - isRegexp (boolean) = false
  - type (string) = 'undefined'
  - propertyIndex (boolean) = false
  - notNullCheckEnabled (boolean) = false
  - nullCheckEnabled (boolean) = false
  - excludeFromAggregation (boolean) = false
  - weight (long) = -1
</pre></div></div>
<p>Following are the details about the above mentioned config options which can be defined at the property definition level</p>

<dl>
<dt>name</dt>
<dd>Property name. If not defined then property name is set to the node name.  If <tt>isRegexp</tt> is true then it defines the regular expression. Can also be set  to a relative property.</dd>
<dt>isRegexp</dt>
<dd>If set to true then property name would be interpreted as a regular  expression and the given definition would be applicable for matching property  names. Note that expression should be structured such that it does not  match &#x2018;/&#x2019;.
  
<ul>
    
<li><tt>.*</tt> - This property definition is applicable for all properties of given  node</li>
    
<li><tt>jcr:content/metadata/.*</tt> - This property definition is  applicable for all properties of child node <i>jcr:content/metadata</i></li>
  </ul></dd>
<dt>boost</dt>
<dd>If the property is included in <tt>nodeScopeIndex</tt> then it defines the boost  done for the index value against the given property name. See  <a href="#boost">Boost and Search Relevancy</a> for more details</dd>
<dt>index</dt>
<dd>Determines if this property should be indexed. Mostly useful for fulltext  index where some properties need to be <i>excluded</i> from getting indexed.</dd>
<dt>useInExcerpt</dt>
<dd>Controls whether the value of a property should be used to create an excerpt.  The value of the property is still full-text indexed when set to false, but it  will never show up in an excerpt for its parent node. If set to true then  property value would be stored separately within index causing the index  size to increase. So set it to true only if you make use of excerpt feature</dd>
<dt>nodeScopeIndex</dt>
<dd>Control whether the value of a property should be part of fulltext index. That  is, you can do a <i>jcr:contains(., &#x2018;foo&#x2019;)</i> and it will return nodes that have a  string property that contains the word foo. Example
  
<ul>
    
<li><i>//element(*, app:Asset)[jcr:contains(., &#x2018;image&#x2019;)]</i></li>
  </ul></dd>
</dl>
<p>In case of aggregation all properties would be indexed at node level by default  if the property type is part of <tt>includePropertyTypes</tt>. However if there is an  explicit property definition provided then it would only be included if  <tt>nodeScopeIndex</tt> is set to true.</p>

<dl>
<dt>analyzed</dt>
<dd>Set this to true if the property is used as part of <tt>contains</tt>. Example
  
<ul>
    
<li><i>//element(*, app:Asset)[jcr:contains(type, &#x2018;image&#x2019;)]</i></li>
    
<li><i>//element(*, app:Asset)[jcr:contains(jcr:content/metadata/@format, &#x2018;image&#x2019;)]</i></li>
  </ul></dd>
<dt><a name="ordered"></a></dt>
<dt>ordered</dt>
<dd>If the property is to be used in <i>order by</i> clause to perform sorting then  this should be set to true. This should be set to true only if the property  is to be used to perform sorting as it increases the index size. Example
  
<ul>
    
<li><i>//element(*, app:Asset)[jcr:contains(type, &#x2018;image&#x2019;)] order by @size</i></li>
    
<li><i>//element(*, app:Asset)[jcr:contains(type, &#x2018;image&#x2019;)] order by jcr:content/@jcr:lastModified</i></li>
  </ul></dd>
</dl>
<p>Refer to <a class="externalLink" href="https://issues.apache.org/jira/browse/OAK-2196">Lucene based Sorting</a> for more details. Note that this is  only supported for single value property. Enabling this on multi value property  would cause indexing to fail.</p>

<dl>
<dt>type</dt>
<dd>JCR Property type. Can be one of <tt>Date</tt>, <tt>Boolean</tt>, <tt>Double</tt> , <tt>String</tt> or <tt>Long</tt>. Mostly  inferred from the indexed value. However in some cases where same property  type is not used consistently across various nodes then it would recommended  to specify the type explicitly.</dd>
<dt>propertyIndex</dt>
<dd>Whether the index for this property is used for equality conditions, ordering,  and is not null conditions.</dd>
<dt>notNullCheckEnabled</dt>
<dd>Since 1.1.8</dd>
<dd>If the property is checked for <i>is not null</i> then this should be set to true.  To reduce the index size,  this should only be enabled for nodeTypes that are not generic.
  
<ul>
    
<li>_//element(*, app:Asset)[jcr:content/@excludeFromSearch]</li>
  </ul></dd>
</dl>
<p>For details, see <a class="externalLink" href="https://issues.apache.org/jira/browse/OAK-2234">IS NOT NULL support</a>.</p>

<dl>
<dt>nullCheckEnabled</dt>
<dd>Since 1.0.12</dd>
<dd>If the property is checked for <i>is null</i> then this should be set to true. This  should only be enabled for nodeTypes that are not generic as it leads to index  entry for all nodes of that type where this property is not set.
  
<ul>
    
<li>_//element(*, app:Asset)[not(jcr:content/@excludeFromSearch)]</li>
  </ul></dd>
</dl>
<p>It would be better to use a query which checks for property existence or property  being set to specific values as such queries can make use of index without any  extra storage cost.</p>
<p>For details, see <a class="externalLink" href="https://issues.apache.org/jira/browse/OAK-2517">IS NULL support</a>.</p>

<dl>
<dt>excludeFromAggregation</dt>
<dd>Since 1.0.27, 1.2.11</dd>
<dd>if set to true the property would be excluded from aggregation <a class="externalLink" href="https://issues.apache.org/jira/browse/OAK-3981">OAK-3981</a></dd>
<dt><a name="weight"></a></dt>
<dt>weight</dt>
<dd>Since 1.6.3</dd>
<dd>At times, we have property definitions which are added to support for dense results right out of  the index (e.g. <tt>contains(*, 'foo') AND [bar]='baz'</tt>). In such cases, the added property definition &#x201c;might&#x201d;  not be the best one to answer queries which only have the property restriction (eg only <tt>[bar]='baz'</tt>). This  can happen when that index specifies some exclude paths and hence does not index all <tt>bar</tt> properties.</dd>
</dl>
<p>For such cases set <tt>weight</tt> to <tt>0</tt> for such properties. In such a case IndexPlanner would not use those property  definitions to determine if that index can answer the query but it would still use them if some other index entry  causes that index to be selected for evaluating such a query.</p>
<p>Refer <a class="externalLink" href="https://issues.apache.org/jira/browse/OAK-5899">OAK-5899</a> for more details</p>
<p><a name="property-names"></a><b>Property Names</b></p>
<p>Property name can be one of following</p>

<ol style="list-style-type: decimal">
  
<li>Simple name - Like <i>assetType</i> etc. These are used for properties which are  defined directly on the indexed node</li>
  
<li>Relative name - Like <i>jcr:content/metadata/title</i>. These are used for  properties which are defined relative to the node being indexed.</li>
  
<li>Regular Expression - Like <i>.*</i>. Used when only property whose name  match given pattern are to be indexed.  They can also be used for relative properties like  <i>jcr:content/metadata/dc:.*$</i>  which indexes all property names starting with <i>dc</i> from node with  relative path <i>jcr:content/metadata</i></li>
  
<li>The string <tt>:nodeName</tt> - this special case indexes node name as if it&#x2019;s a  virtual property of the node being indexed. Setting this along with  <tt>nodeScopeIndex=true</tt> is akin to setting <tt>indexNodeName=true</tt> on indexing  rule. (<tt>@since Oak 1.3.15, 1.2.14</tt>)</li>
</ol></div>
<div class="section">
<h5><a name="Evaluate_Path_Restrictions"></a><a name="path-restrictions"></a> Evaluate Path Restrictions</h5>
<p>Lucene index provides support for evaluating path restrictions natively. Consider a query like</p>

<div class="source">
<div class="source"><pre class="prettyprint">select * from [app:Asset] as a where isdescendantnode(a, [/content/app/old]) AND contains(*, 'white')
</pre></div></div>
<p>By default the index would return all node which <i>contain white</i> and Query engine would filter out nodes which are not under <i>/content/app/old</i>. This can perform slow if lots of nodes are not under that path. To speed up such queries one can enable <tt>evaluatePathRestrictions</tt> in Lucene index and index would only return nodes which are under <i>/content/app/old</i>.</p>
<p>Enabling this feature would incur cost in terms of slight increase in index size. Refer to <a class="externalLink" href="https://issues.apache.org/jira/browse/OAK-2306">OAK-2306</a> for more details.</p></div>
<div class="section">
<h5><a name="Include_and_Exclude_paths_from_indexing"></a><a name="include-exclude"></a> Include and Exclude paths from indexing</h5>
<p><tt>@since Oak 1.0.14, 1.2.3</tt></p>
<p>By default the indexer would index all the nodes under the subtree where the index definition is defined as per the indexingRule. In some cases its required to index nodes under certain path. For e.g. if index is defined for global fulltext index which include the complete repository you might want to exclude certain path which contains transient system data. </p>
<p>For example if you application stores certain logs under <tt>/var/log</tt> and it is not supposed to be indexed as part of fulltext index then it can be excluded</p>

<div class="source">
<div class="source"><pre class="prettyprint">/oak:index/assetType
  - jcr:primaryType = &quot;oak:QueryIndexDefinition&quot;
  - compatVersion = 2
  - type = &quot;lucene&quot;
  - excludedPaths = [&quot;/var/log&quot;]
</pre></div></div>
<p>Above index definition would cause nodes under <tt>/var/log</tt> not to be indexed. In majority of case <tt>excludedPaths</tt> only makes sense. However in some cases it might be required to also specify explicit set of path which should be indexed. In that case make use of <tt>includedPaths</tt></p>
<p>Note that <tt>excludedPaths</tt> and <tt>includedPaths</tt> <i>does not</i> affect the index selection logic for a query i.e. if a query has any path restriction specified then that would not be checked against the <tt>excludedPaths</tt> and <tt>includedPaths</tt>.</p>
<p><a name="query-paths"></a> <b>queryPaths</b></p>
<p>If you need to ensure that a given index only gets used for query with specific path restrictions then you need to specify those paths in <tt>queryPaths</tt>. </p>
<p>For example if <tt>includedPaths</tt> and <tt>queryPaths</tt> are set to <i>[ &#x201c;/content/a&#x201d;, &#x201c;/content/b&#x201d; ]</i>. The index would be used for queries below &#x201c;/content/a&#x201d; as well as for queries below &#x201c;/content/b&#x201d;. But not for queries without path restriction, or for queries below &#x201c;/content/c&#x201d;.</p>
<p><b>Usage</b></p>
<p>Key points to consider while using <tt>excludedPaths</tt>, <tt>includedPaths</tt> and <tt>queryPaths</tt></p>

<ol style="list-style-type: decimal">
  
<li>
<p>Reduce what gets indexed in global fulltext index - For  setups where a global fulltext index is configured say at /oak:index/lucene which  indexes everything then <tt>excludedPaths</tt> can be used to avoid indexing transient  repository state like in &#x2018;/var&#x2019; or &#x2018;/tmp&#x2019;. This would help in improving indexing  rate. By far this is the primary usecase</p></li>
  
<li>
<p>Reduce reindexing time - If its known that certain type of data is stored under specific  subtree only but the query is not specifying that path restriction then <tt>includedPaths</tt>  can be used to reduce reindexing time for existing content by ensuring that indexing  logic only traverses that path for building up the index</p></li>
  
<li>
<p>Use <tt>excludedPaths</tt>, <tt>includedPaths</tt> with caution - When paths are excluded or included  then query engine is not aware of that. If wrong paths get excluded then its possible  that nodes which should have been part of query result get excluded as they are not indexed.  So only exclude those paths which do not have node matching given nodeType or nodes which  are known to be not part of any query result</p></li>
  
<li>
<p>Sub-root index definitions (e.g. <tt>/test/oak:index/index-def-node</tt>) -  <tt>excludedPaths</tt> and <tt>includedPaths</tt> need to be relative to the path that index is defined for. e.g. if the condition is supposed to be put for <tt>/test/a</tt> where the index definition is at <tt>/test/oak:index/index-def-node</tt> then <tt>/a</tt> needs to be put as value of <tt>excludedPaths</tt> or <tt>includedPaths</tt>. On the other hand, <tt>queryPaths</tt> remains to be an absolute path. So, for the example above, <tt>queryPaths</tt> would get the value <tt>/test/a</tt>.</p></li>
</ol>
<p>In most cases use of <tt>queryPaths</tt> would not be required as index definition should not have any overlap. </p>
<p>Refer to <a class="externalLink" href="https://issues.apache.org/jira/browse/OAK-2599">OAK-2599</a> for more details.</p></div></div>
<div class="section">
<h4><a name="Aggregation"></a><a name="aggregation"></a>Aggregation</h4>
<p>Sometimes it is useful to include the contents of descendant nodes into a single node to easier search on content that is scattered across multiple nodes.</p>
<p>Oak allows you to define index aggregates based on relative path patterns and primary node types. Changes to aggregated items cause the main item to be reindexed, even if it was not modified.</p>
<p>Aggregation configuration is defined under the <tt>aggregates</tt> node under index configuration. The following example creates an index aggregate on nt:file that includes the content of the jcr:content node:</p>

<div class="source">
<div class="source"><pre class="prettyprint">fulltextIndex
  - jcr:primaryType = &quot;oak:QueryIndexDefinition&quot;
  - compatVersion = 2
  - type = &quot;lucene&quot;
  - async = &quot;async&quot;
  + aggregates
    + nt:file
      + include0
        - path = &quot;jcr:content&quot;
</pre></div></div>
<p>By default all properties whose type matches <tt>includePropertyTypes</tt> and are part of child nodes as per the aggregation pattern are included for indexing. For excluding certain properties define a property definition with relative path and set <tt>excludeFromAggregation</tt> to <tt>true</tt>. Such properties would then be excluded from fulltext index</p>
<p>For a given nodeType multiple includes can be defined. Below is the aggregate definition structure for any specific include rule</p>

<div class="source">
<div class="source"><pre class="prettyprint">aggregateNodeInclude (nt:unstructured)
  - path (string) mandatory
  - primaryType (string)
  - relativeNode (boolean) = false
</pre></div></div>
<p>Following are the details about the above mentioned config options which can be defined as part of aggregation include. (Refer to <a class="externalLink" href="https://issues.apache.org/jira/browse/OAK-2268">OAK-2268</a> for implementation details)</p>

<dl>
<dt>path</dt>
<dd>Path pattern to include. Example
  
<ul>
    
<li><tt>jcr:content</tt> - Name explicitly specified</li>
    
<li><tt>*</tt> - Any child node at depth 1</li>
    
<li><tt>*/*</tt> - Any child node at depth 2</li>
  </ul></dd>
<dt>primaryType</dt>
<dd>
<p>Restrict the included nodes to a certain type. The restriction would be  applied on the last node in given path</p>
  
<div class="source">
<div class="source"><pre class="prettyprint">+ aggregates
  + nt:file
    + include0
      - path = &quot;jcr:content&quot;
      - primaryType = &quot;nt:resource&quot;
</pre></div></div></dd>
<dt>relativeNode</dt>
<dd>
<p>Boolean property indicates that query can be performed against specific node  For example for following content</p>
  
<div class="source">
<div class="source"><pre class="prettyprint">+ space.txt (app:Asset)
  + renditions (nt:folder)
    + original (nt:file)
      + jcr:content (nt:resource)
        - jcr:data
</pre></div></div></dd>
</dl>
<p>And a query like</p>

<div class="source">
<div class="source"><pre class="prettyprint">    select * from [app:Asset] where contains([renditions/original/*], &quot;pluto&quot;)
</pre></div></div>
<p>Following index configuration would be required</p>

<div class="source">
<div class="source"><pre class="prettyprint">    fulltextIndex
      - jcr:primaryType = &quot;oak:QueryIndexDefinition&quot;
      - compatVersion = 2
      - type = &quot;lucene&quot;
      - async = &quot;async&quot;
      + aggregates
        + nt:file
          + include0
            - path = &quot;jcr:content&quot;
        + app:Asset
          + include0
            - path = &quot;renditions/original&quot;
            - relativeNode = true
      + indexRules
        - jcr:primaryType = &quot;nt:unstructured&quot;
        + app:Asset
</pre></div></div>
<p><b>Aggregation and Recursion</b></p>
<p>While performing aggregation the aggregation rules are again applied on node being aggregated. For example while aggregating for <i>app:Asset</i> above when <i>renditions/original/*</i> is being aggregated then aggregation rule would again be applied. In this case as <i>renditions/original</i> is <i>nt:file</i> then aggregation rule applicable for <i>nt:file</i> would be applied. Such a logic might result in recursion. (See <a class="externalLink" href="https://issues.apache.org/jira/browse/JCR-2989?focusedCommentId=13051101">JCR-2989</a> for details).</p>
<p>For such case <tt>reaggregateLimit</tt> is set on aggregate definition node and defaults to 5</p>

<div class="source">
<div class="source"><pre class="prettyprint">  + aggregates
    + app:Asset
      - reaggregateLimit (long) = 5
      + include0
        - path = &quot;renditions/original&quot;
        - relativeNode = true
</pre></div></div></div>
<div class="section">
<h4><a name="Analyzers"></a><a name="analyzers"></a>Analyzers</h4>
<p><tt>@since Oak 1.5.5, 1.4.7, 1.2.19</tt> Unless custom analyzer is configured (as documented below), in-built analyzer can be configured to include original term as well to be indexed. This is controlled by setting boolean property <tt>indexOriginalTerm</tt> on analyzers node.</p>

<div class="source">
<div class="source"><pre class="prettyprint">/oak:index/assetType
  - jcr:primaryType = &quot;oak:QueryIndexDefinition&quot;
  - compatVersion = 2
  - type = &quot;lucene&quot;
  + analyzers
    - indexOriginalTerm = true
</pre></div></div>
<p>(See <a class="externalLink" href="https://issues.apache.org/jira/browse/OAK-4516">OAK-4516</a> for details)</p>
<p><tt>@since Oak 1.2.0</tt></p>
<p>Analyzers can be configured as part of index definition via <tt>analyzers</tt> node. The default analyzer can be configured via <tt>analyzers/default</tt> node</p>

<div class="source">
<div class="source"><pre class="prettyprint">+ sampleIndex
    - jcr:primaryType = &quot;oak:QueryIndexDefinition&quot;
    + analyzers
        + default
        + pathText
        ...
</pre></div></div>
<div class="section">
<h5><a name="Specify_analyzer_class_directly"></a><a name="analyzer-classes"></a>Specify analyzer class directly</h5>
<p>If any of the out of the box analyzer is to be used then it can configured directly</p>

<div class="source">
<div class="source"><pre class="prettyprint">+ analyzers
        + default
            - class = &quot;org.apache.lucene.analysis.standard.StandardAnalyzer&quot;
            - luceneMatchVersion = &quot;LUCENE_47&quot; (optional)
</pre></div></div>
<p>To confirm to specific version specify it via <tt>luceneMatchVersion</tt> otherwise Oak would use a default version depending on version of Lucene it is shipped with.</p>
<p>One can also provide a stopword file via <tt>stopwords</tt> <tt>nt:file</tt> node under the analyzer node</p>

<div class="source">
<div class="source"><pre class="prettyprint">+ analyzers
        + default
            - class = &quot;org.apache.lucene.analysis.standard.StandardAnalyzer&quot;
            - luceneMatchVersion = &quot;LUCENE_47&quot; (optional)
            + stopwords (nt:file)
</pre></div></div></div>
<div class="section">
<h5><a name="Create_analyzer_via_composition"></a><a name="analyzer-composition"></a>Create analyzer via composition</h5>
<p>Analyzers can also be composed based on <tt>Tokenizers</tt>, <tt>TokenFilters</tt> and <tt>CharFilters</tt>. This is similar to the support provided in Solr where you can <a class="externalLink" href="https://wiki.apache.org/solr/AnalyzersTokenizersTokenFilters#Specifying_an_Analyzer_in_the_schema">configure analyzers in xml</a></p>

<div class="source">
<div class="source"><pre class="prettyprint">+ analyzers
        + default
            + charFilters (nt:unstructured) //The filters needs to be ordered
                + HTMLStrip
                + Mapping
            + tokenizer
                - name = &quot;Standard&quot;
            + filters (nt:unstructured) //The filters needs to be ordered
                + LowerCase
                + Stop
                    - words = &quot;stop1.txt, stop2.txt&quot;
                    + stop1.txt (nt:file)
                    + stop2.txt (nt:file)
                + PorterStem
                + Synonym
                    - synonyms = &quot;synonym.txt&quot;
                    + synonym.txt (nt:file)
</pre></div></div>
<p>Points to note</p>

<ol style="list-style-type: decimal">
  
<li>Name of filters, charFilters and tokenizer are formed by removing the  factory suffixes. So
  
<ul>
    
<li>org.apache.lucene.analysis.standard.StandardTokenizerFactory -&gt; <tt>Standard</tt></li>
    
<li>org.apache.lucene.analysis.charfilter.MappingCharFilterFactory -&gt; <tt>Mapping</tt></li>
    
<li>org.apache.lucene.analysis.core.StopFilterFactory -&gt; <tt>Stop</tt></li>
  </ul></li>
  
<li>Any config parameter required for the factory is specified as property of  that node
  
<ul>
    
<li>If the factory requires to load a file e.g. stop words from some file then  file content can be provided via creating child <tt>nt:file</tt> node of the  filename</li>
    
<li>The property value MUST be of type <tt>String</tt>. No other JCR type should be used  for them like array or integer etc</li>
  </ul></li>
  
<li>The analyzer-chain processes text from nodes as well text passed in query. So,  do take care that any mapping configuration (e.g. synonym mappings) factor in  the chain of analyzers.  E.g a common mistake for synonym mapping would be to have <tt>domain =&gt; Range</tt> while  there&#x2019;s a lower case filter configured as well (see the example above). For such  a setup an indexed value <tt>domain</tt> would actually get indexed as <tt>Range</tt> (mapped  value doesn&#x2019;t have lower case filter below it) but a query for <tt>Range</tt> would actually  query for <tt>range</tt> (due to lower case filter) and won&#x2019;t give the result (as might be  expected). An easy work-around for this example could be to have lower case mappings  i.e. just use <tt>domain =&gt; range</tt>.</li>
  
<li>Precedence: Specifying analyzer class directly has precedence over analyzer configuration  by composition. If you want to configure analyzers by composition then analyzer class  MUST NOT not be specified. In-build analyzer has least precedence and comes into play only  if no custom analyzer has been configured. Similarly, setting <tt>indexOriginalTerm</tt> on  analyzers node to modify behavior of in-built analyzer also works only when no custom  analyzer has been configured.</li>
  
<li>To determine list of supported factories have a look at Lucene javadocs for
  
<ul>
    
<li><a class="externalLink" href="https://lucene.apache.org/core/4_7_1/analyzers-common/org/apache/lucene/analysis/util/TokenizerFactory.html">TokenizerFactory</a></li>
    
<li><a class="externalLink" href="https://lucene.apache.org/core/4_7_1/analyzers-common/org/apache/lucene/analysis/util/CharFilterFactory.html">CharFilterFactory</a></li>
    
<li><a class="externalLink" href="https://lucene.apache.org/core/4_7_1/analyzers-common/org/apache/lucene/analysis/util/TokenFilterFactory.html">FilterFactory</a></li>
  </ul></li>
  
<li>Oak support for composing analyzer is based on Lucene. So some helpful docs around this
  
<ul>
    
<li><a class="externalLink" href="https://cwiki.apache.org/confluence/display/solr/Understanding+Analyzers%2C+Tokenizers%2C+and+Filters">https://cwiki.apache.org/confluence/display/solr/Understanding+Analyzers%2C+Tokenizers%2C+and+Filters</a></li>
    
<li><a class="externalLink" href="https://cwiki.apache.org/confluence/display/solr/CharFilterFactories">https://cwiki.apache.org/confluence/display/solr/CharFilterFactories</a></li>
    
<li><a class="externalLink" href="https://wiki.apache.org/solr/AnalyzersTokenizersTokenFilters#Specifying_an_Analyzer_in_the_schema">https://wiki.apache.org/solr/AnalyzersTokenizersTokenFilters#Specifying_an_Analyzer_in_the_schema</a></li>
  </ul></li>
  
<li>When defining synonyms:
  
<ul>
    
<li>in the synonym file, lines like <i>plane, airplane, aircraft</i> refer to tokens that are mutual synoyms whereas lines like <i>plane =&gt; airplane</i> refer to <i>one way</i> synonyms, so that plane will be expanded to airplane but not vice versa</li>
    
<li>continuing with the point above, since oak would use the same analyzer for indexing as well as querying, using one-way synonyms in any practical way is not supported at the moment.</li>
    
<li>special characters have to be escaped</li>
    
<li>multi word synonyms need particular attention (see <a class="externalLink" href="https://lucidworks.com/2014/07/12/solution-for-multi-term-synonyms-in-lucenesolr-using-the-auto-phrasing-tokenfilter">https://lucidworks.com/2014/07/12/solution-for-multi-term-synonyms-in-lucenesolr-using-the-auto-phrasing-tokenfilter</a>)</li>
  </ul></li>
</ol>
<p>Note that currently only one analyzer can be configured per index. Its not possible to specify separate analyzer for query and index time currently. </p></div></div>
<div class="section">
<h4><a name="Codec"></a><a name="codec"></a>Codec</h4>
<p>Name of <a class="externalLink" href="https://lucene.apache.org/core/4_7_1/core/org/apache/lucene/codecs/Codec.html">Lucene Codec</a> to use. By default if the index involves fulltext indexing then Oak Lucene uses <tt>OakCodec</tt> which disables compression. Due to this the index size may grow large. To enable compression you can set the codec to <tt>Lucene46</tt></p>

<div class="source">
<div class="source"><pre class="prettyprint">/oak:index/assetType
  - jcr:primaryType = &quot;oak:QueryIndexDefinition&quot;
  - compatVersion = 2
  - type = &quot;lucene&quot;
  - codec = &quot;Lucene46&quot;
</pre></div></div>
<p>Refer to <a class="externalLink" href="https://issues.apache.org/jira/browse/OAK-2853">OAK-2853</a> for details. Enabling the <tt>Lucene46</tt> codec would lead to smaller and compact indexes.</p></div>
<div class="section">
<h4><a name="Boost_and_Search_Relevancy"></a><a name="boost"></a>Boost and Search Relevancy</h4>
<p><tt>@since Oak 1.2.5</tt></p>
<p>When fulltext indexing is enabled then internally Oak would create a fulltext field which consists of text extracted from various other fields i.e. fields for which <tt>nodeScopeIndex</tt> is <tt>true</tt>. This allows search like <tt>//*[jcr:contains(., 'foo')]</tt> to perform search across any indexable field containing foo (See <a class="externalLink" href="http://www.day.com/specs/jcr/1.0/6.6.5.2_jcr_contains_Function.html">contains function</a> for details)</p>
<p>In certain cases its desirable that those nodes where the searched term is present in a specific property are ranked higher (come earlier in search result) compared to those node where the searched term is found in some other property.</p>
<p>In such cases it should be possible to boost specific text contributed by individual property. Meaning that if a title field is boosted more than description, then search result would those node coming earlier where searched term is found in title field</p>
<p>For that to work ensure that for each such property (which need to be preferred) both <tt>nodeScopeIndex</tt> and <tt>analyzed</tt> are set to true. In addition you can specify <tt>boost</tt> property so give higher weightage to values found in specific property</p>
<p>Note that even without setting explicit <tt>boost</tt> and just setting <tt>nodeScopeIndex</tt> and <tt>analyzed</tt> to true would improve the search result due to the way <a class="externalLink" href="https://wiki.apache.org/lucene-java/LuceneFAQ#How_do_I_make_sure_that_a_match_in_a_document_title_has_greater_weight_than_a_match_in_a_document_body.3F">Lucene does scoring</a>. Internally Oak would create separate Lucene fields for those jcr properties and would perform a search across all such fields. For more details refer to <a class="externalLink" href="https://issues.apache.org/jira/browse/OAK-3367">OAK-3367</a></p>

<div class="source">
<div class="source"><pre class="prettyprint">  + indexRules
    - jcr:primaryType = &quot;nt:unstructured&quot;
    + app:Asset
      + properties
        - jcr:primaryType = &quot;nt:unstructured&quot;
        + description
          - nodeScopeIndex = true
          - analyzed = true
          - name = &quot;jcr:content/metadata/jcr:description&quot;
        + title
          - analyzed = true
          - nodeScopeIndex = true
          - name = &quot;jcr:content/metadata/jcr:title&quot;
          - boost = 2.0
</pre></div></div>
<p>With above index config a search like</p>

<div class="source">
<div class="source"><pre class="prettyprint">SELECT
  *
FROM [app:Asset] 
WHERE 
  CONTAINS(., 'Batman')
</pre></div></div>
<p>Would have those node (of type app:Asset) come first where <i>Batman</i> is found in <i>jcr:title</i>. While those nodes where search text is found in other field like aggregated content would come later</p></div>
<div class="section">
<h4><a name="Effective_Index_Definition"></a><a name="stored-index-definition"></a>Effective Index Definition</h4>
<p><tt>@since Oak 1.6</tt></p>
<p>Prior to Oak 1.6 index definition as defined in content was directly used for query execution and indexing. It was possible that index definition is modified in incompatible way and that would start affecting the query execution leading to inconsistent result.</p>
<p>Since Oak 1.6 the index definitions are cloned upon reindexing and stored in a hidden structure. For further incremental indexing and for query plan calculation the stored index definition is used. So any changes done post reindex to index definition would not be applicable untill a reindex is done.</p>
<p>There would be some cases where changes in index definition does not require a reindex. For e.g. if a new property is being introduced in content model and no prior content exist with such a property then its safe to index such a property without doing a reindex. For such cases user must follow below steps</p>

<ol style="list-style-type: decimal">
  
<li>Make the required changes</li>
  
<li>Set <tt>refresh</tt> property to <tt>true</tt> in index definition node</li>
  
<li>Save the changes</li>
</ol>
<p>On next async indexing cycle this flag would be pickedup and stored index definition would be refreshed. <i>Post this the flag would be automatically removed and a log message would be logged</i>. You would also see a log message like below</p>

<div class="source">
<div class="source"><pre class="prettyprint">LuceneIndexEditorContext - Refreshed the index definition for [/oak:index/fooLuceneIndex] 
</pre></div></div>
<p>To simplify troubleshooting the stored index definition can be accessed from <tt>LuceneIndexMBean</tt> via <tt>getStoredIndexDefinition</tt> operation. It would dump the string representation of stored NodeState</p>
<p><img src="lucene-index-mbean-dump-index.png" alt="Dump Stored Index Definition" /></p>
<p>This feature can be disabled by setting OSGi property <tt>disableStoredIndexDefinition</tt> for <tt>LuceneIndexProviderService</tt> to true. Once disable any change in index definition would start effecting the query plans</p>
<p>Refer to <a class="externalLink" href="https://issues.apache.org/jira/browse/OAK-4400">OAK-4400</a> for more details.</p></div>
<div class="section">
<h4><a name="Generating_Index_Definition"></a><a name="generate-index-definition"></a> Generating Index Definition</h4>
<p>To simplify generating index definition suitable for evaluating certain set of queries you can make use of <a class="externalLink" href="http://oakutils.appspot.com/generate/index">http://oakutils.appspot.com/generate/index</a>. Here you can provide a set of queries and then it would generate the suitable index definitions for those queries.</p>
<p>Note that you would still need to tweak the definition for aggregation, path include exclude etc as that data cannot be inferred from the query</p></div></div>
<div class="section">
<h3><a name="Near_Real_Time_Indexing"></a><a name="nrt-indexing"></a> Near Real Time Indexing</h3>
<p><tt>@since Oak 1.6</tt></p>
<p>Refer to <a href="indexing.html#nrt-indexing">Near realtime indexing</a> for more details</p></div>
<div class="section">
<h3><a name="LuceneIndexProvider_Configuration"></a><a name="osgi-config"></a>LuceneIndexProvider Configuration</h3>
<p>Some of the runtime aspects of the Oak Lucene support can be configured via OSGi configuration. The configuration needs to be done for PID <tt>org.apache
.jackrabbit.oak.plugins.index.lucene.LuceneIndexProviderService</tt></p>
<p><img src="lucene-osgi-config.png" alt="OSGi Configuration" /></p>

<dl>
<dt>enableCopyOnReadSupport</dt>
<dd>Enable copying of Lucene index to local file system to improve query performance. See <a href="#copy-on-read">Copy Indexes On Read</a></dd>
<dt>enableCopyOnWriteSupport</dt>
<dd>Enable copying of Lucene index to local file system to improve indexing performance. See <a href="#copy-on-write">Copy Indexes On Write</a></dd>
<dt>localIndexDir</dt>
<dd>Directory to be used for when copy index files to local file system. To be specified when <tt>enableCopyOnReadSupport</tt> is enabled</dd>
<dt>prefetchIndexFiles</dt>
<dd>Prefetch the index files when CopyOnRead is enabled. When enabled all new Lucene index files would be copied locally before the index is made available to QueryEngine (1.0.17,1.2.3)</dd>
<dt>debug</dt>
<dd>Boolean value. Defaults to <tt>false</tt></dd>
<dd>If enabled then Lucene logging would be integrated with Slf4j</dd>
</dl></div>
<div class="section">
<h3><a name="Tika_Config"></a><a name="tika-config"></a>Tika Config</h3>
<p><tt>@since Oak 1.0.12, 1.2.3</tt></p>
<p>Oak Lucene uses <a class="externalLink" href="http://tika.apache.org/">Apache Tika</a> to extract the text from binary content</p>

<div class="source">
<div class="source"><pre class="prettyprint">+ tika
    - maxExtractLength (long) = -10
    + config.xml  (nt:file)
      + jcr:content
        - jcr:data = //config xml binary content
</pre></div></div>
<p>Oak uses a <a class="externalLink" href="https://github.com/apache/jackrabbit-oak/blob/trunk/oak-lucene/src/main/resources/org/apache/jackrabbit/oak/plugins/index/lucene/tika-config.xml">default config</a>. To use a custom config specify the config file via <tt>tika/config.xml</tt> node in index config. </p>

<dl>
<dt><a class="externalLink" href="https://issues.apache.org/jira/browse/OAK-2470">maxExtractLength</a></dt>
<dd>Limits the number of characters that are extracted by the Tika parse. A negative  value indicates a multiple of <tt>maxFieldLength</tt> and a positive value is used as is
  
<ul>
    
<li>maxExtractLength = -10, maxFieldLength = 10000 -&gt; Actual value = 100000</li>
    
<li>maxExtractLength = 1000 -&gt; Actual value = 1000</li>
  </ul></dd>
</dl>
<div class="section">
<h4><a name="Mime_type_usage"></a><a name="mime-type-usage"></a>Mime type usage</h4>
<p>A binary would only be index if there is an associated property <tt>jcr:mimeType</tt> defined and that is supported by Tika. By default indexer uses <a class="externalLink" href="https://issues.apache.org/jira/browse/OAK-2895">TypeDetector</a> instead of default <tt>DefaultDetector</tt> which relies on the <tt>jcr:mimeType</tt> to pick up the right parser. </p></div>
<div class="section">
<h4><a name="Mime_type_mapping"></a><a name="mime-type-mapping"></a>Mime type mapping</h4>
<p><tt>@since Oak 1.7.7</tt></p>
<p>In certain circumstances, it may be desired to pass a value other than the <tt>jcr:mimeType</tt> property into the Tika parser. For example, this would be necessary if a binary has an application-specific mime type, but is parsable by the standard Tika parser for some generic type. To support these cases, create a node structure under the <tt>tika/mimeTypes</tt> node following the mime type structure, e.g.</p>

<div class="source">
<div class="source"><pre class="prettyprint">+ tika
    + mimeTypes (nt:unstructured)
      + application (nt:unstructured)
        + vnd.mycompany-document (nt:unstructured)
          - mappedType = application/pdf
</pre></div></div>
<p>When this index is indexing a binary of type <tt>application/vnd.mycompany-document</tt> it will force Tika to treat it as a binary of type <tt>application/pdf</tt>.</p></div></div>
<div class="section">
<h3><a name="Non_Root_Index_Definitions"></a><a name="non-root-index"></a>Non Root Index Definitions</h3>
<p>Lucene index definition can be defined at any location in repository and need not always be defined at root. For example if your query involves path restrictions like</p>

<div class="source">
<div class="source"><pre class="prettyprint">select * from [app:Asset] as a where ISDESCENDANTNODE(a, '/content/companya') and [format] = 'image'
</pre></div></div>
<p>Then you can create the required index definition say <tt>assetIndex</tt> at <tt>/content/companya/oak:index/assetIndex</tt>. In such a case that index would contain data for the subtree under <tt>/content/companya</tt></p></div>
<div class="section">
<h3><a name="Native_Query_and_Index_Selection"></a><a name="native-query"></a>Native Query and Index Selection</h3>
<p>Oak query engine supports native queries like</p>

<div class="source">
<div class="source"><pre class="prettyprint">//*[rep:native('lucene', 'name:(Hello OR World)')]
</pre></div></div>
<p>If multiple Lucene based indexes are enabled on the system and you need to make use of specific Lucene index like <tt>/oak:index/assetIndex</tt> then you can specify the index name via <tt>functionName</tt> attribute on index definition. </p>
<p>For example for assetIndex definition like </p>

<div class="source">
<div class="source"><pre class="prettyprint">- jcr:primaryType = &quot;oak:QueryIndexDefinition&quot;
- type = &quot;lucene&quot;
...
- functionName = &quot;lucene-assetIndex&quot;
</pre></div></div>
<p>Executing following query would ensure that Lucene index from <tt>assetIndex</tt> should be used</p>

<div class="source">
<div class="source"><pre class="prettyprint">//*[rep:native('lucene-assetIndex', 'name:(Hello OR World)')]
</pre></div></div></div>
<div class="section">
<h3><a name="Persisting_indexes_to_FileSystem"></a><a name="native-query"></a>Persisting indexes to FileSystem</h3>
<p>By default Lucene indexes are stored in the <tt>NodeStore</tt>. If required they can be stored on the file system directly</p>

<div class="source">
<div class="source"><pre class="prettyprint">- jcr:primaryType = &quot;oak:QueryIndexDefinition&quot;
- type = &quot;lucene&quot;
...
- persistence = &quot;file&quot;
- path = &quot;/path/to/store/index&quot;
</pre></div></div>
<p>To store the Lucene index in the file system, in the Lucene index definition node, set the property <tt>persistence</tt> to <tt>file</tt>, and set the property <tt>path</tt> to the directory where the index should be stored. Then start reindexing by setting <tt>reindex</tt> to <tt>true</tt>.</p>
<p>Note that this setup would only for those non cluster <tt>NodeStore</tt>. If the backend <tt>NodeStore</tt> supports clustering then index data would not be accessible on other cluster nodes</p></div>
<div class="section">
<h3><a name="CopyOnRead"></a><a name="copy-on-read"></a>CopyOnRead</h3>
<p>Lucene indexes are stored in <tt>NodeStore</tt>. Oak Lucene provides a custom directory implementation which enables Lucene to load index from <tt>NodeStore</tt>. This might cause performance degradation if the <tt>NodeStore</tt> storage is remote. For such case Oak Lucene provide a <tt>CopyOnReadDirectory</tt> which copies the index content to a local directory and enables Lucene to make use of local directory based indexes while performing queries.</p>
<p>At runtime various details related to copy on read features are exposed via <tt>CopyOnReadStats</tt> MBean. Indexes at JCR path e.g. <tt>/oak:index/assetIndex</tt> would be copied to <tt>&lt;index dir&gt;/&lt;hash of jcr path&gt;</tt>. To determine mapping between local index directory and JCR path refer to the MBean details</p>
<p><img src="lucene-index-copier-mbean.png" alt="CopyOnReadStats" /></p>
<p>For more details refer to <a class="externalLink" href="https://issues.apache.org/jira/browse/OAK-1724">OAK-1724</a>. This feature can be enabled via <a href="#osgi-config">Lucene Index provider service configuration</a></p>
<p><i>With Oak 1.0.13 this feature is now enabled by default.</i></p></div>
<div class="section">
<h3><a name="CopyOnWrite"></a><a name="copy-on-write"></a>CopyOnWrite</h3>
<p><tt>@since Oak 1.0.15, 1.2.3</tt></p>
<p>Similar to <i>CopyOnRead</i> feature Oak Lucene also supports <i>CopyOnWrite</i> to enable faster indexing by first buffering the writes to local filesystem and transferring them to remote storage asynchronously as the indexing proceeds. This should provide better performance and hence faster indexing times.</p>
<p><b>indexPath</b></p>
<p><i>Not required from Oak 1.6 , 1.4.7+</i> </p>
<p>To speed up the indexing with CopyOnWrite you would also need to set <tt>indexPath</tt> in index definition to the path of index in the repository. For e.g. if your index is defined at <tt>/oak:index/lucene</tt> then value of <tt>indexPath</tt> should be set to <tt>/oak:index/lucene</tt>. This would enable the indexer to perform any read during the indexing process locally and thus avoid costly read from remote.</p>
<p>For more details refer to <a class="externalLink" href="https://issues.apache.org/jira/browse/OAK-2247">OAK-2247</a>. This feature can be enabled via <a href="#osgi-config">Lucene Index provider service configuration</a></p></div>
<div class="section">
<h3><a name="Lucene_Index_MBeans"></a><a name="mbeans"></a>Lucene Index MBeans</h3>
<p>Oak Lucene registers a JMX bean <tt>LuceneIndex</tt> which provide details about the index content e.g. size of index, number of documents present in index etc</p>
<p><img src="lucene-index-mbean.png" alt="Lucene Index MBean" /></p></div>
<div class="section">
<h3><a name="Active_Index_Files_Collection"></a><a name="active-blob-collection"></a>Active Index Files Collection</h3>
<p><tt>@since Oak 1.7.1</tt></p>
<p>Lucene indexing for moderately active repository creates a lot of deleted files. This creates excessive load for usual mark-sweep garbage collection. Since, blobs related to indexed data are explicitly made unique, it&#x2019;s safe to delete them as soon as index node referring that blob is deleted.</p>
<p>Such active deletion of index blobs was implemented in <a class="externalLink" href="https://issues.apache.org/jira/browse/OAK-2808">OAK-2808</a>. The feature periodically deletes blobs which are deleted from the index. This &#x2018;period&#x2019; can be controlled by <tt>deletedBlobsCollectionInterval</tt> property in <a href="#osgi-config">Lucene Index provider service configuration</a>.</p>
<p>The feature would only delete blobs which have been deleted before a certain time. This is 24 hours by default and can be controlled by defining <tt>oak.active.deletion.minAge</tt> as number of hours to not purge a blob after it&#x2019;s deleted from the repository.</p></div>
<div class="section">
<h3><a name="Analyzing_created_Lucene_Index"></a><a name="luke"></a>Analyzing created Lucene Index</h3>
<p><a class="externalLink" href="https://code.google.com/p/luke/">Luke</a> is a handy development and diagnostic tool, which accesses already existing Lucene indexes and allows you to display index details. In Oak Lucene index files are stored in <tt>NodeStore</tt> and hence not directly accessible. To enable analyzing the index files via Luke follow below mentioned steps</p>

<ol style="list-style-type: decimal">
  
<li>
<p>Download the Luke version which includes the matching Lucene jars used by  Oak. As of Oak 1.0.8 release the Lucene version used is 4.7.1. So download the jar from <a class="externalLink" href="https://github.com/DmitryKey/luke/releases">here</a></p>
  
<div class="source">
<div class="source"><pre class="prettyprint">$wget https://github.com/DmitryKey/luke/releases/download/4.7.0/luke-with-deps.jar
</pre></div></div></li>
  
<li>
<p>Use the <a class="externalLink" href="https://github.com/apache/jackrabbit-oak/tree/trunk/oak-run#console">Oak Console</a> to dump the Lucene index from <tt>NodeStore</tt>  to filesystem directory. Use the <tt>lc dump</tt> command</p>
  
<div class="source">
<div class="source"><pre class="prettyprint">$ java -jar oak-run-*.jar console /path/to/oak/repository
Apache Jackrabbit Oak 1.1-SNAPSHOT
Jackrabbit Oak Shell (Apache Jackrabbit Oak 1.1-SNAPSHOT, JVM: 1.7.0_55)
Type ':help' or ':h' for help.
-------------------------------------------------------------------------
/&gt; lc info /oak:index/lucene
Index size : 74.1 MB
Number of documents : 235708
Number of deleted documents : 231
/&gt; lc 
dump   info   
/&gt; lc dump /path/to/dump/index/lucene /oak:index/lucene
Copying Lucene indexes to [/path/to/dump/index/lucene]
Copied 74.1 MB in 1.209 s
/&gt; lc dump /path/to/dump/index/slingAlias /oak:index/slingAlias
Copying Lucene indexes to [/path/to/dump/index/lucene-index/slingAlias]
Copied 8.5 MB in 218.7 ms
/&gt;
</pre></div></div></li>
  
<li>
<p>Post dump open the index via Luke. Oak Lucene uses a <a class="externalLink" href="https://issues.apache.org/jira/browse/OAK-1737">custom  Codec</a>. So oak-lucene jar needs to be included in Luke classpath  for it to display the index details</p>
  
<div class="source">
<div class="source"><pre class="prettyprint">$ java -XX:MaxPermSize=512m -cp luke-with-deps.jar:oak-lucene-1.0.8.jar org.getopt.luke.Luke
</pre></div></div></li>
</ol>
<p>From the Luke UI shown you can access various details.</p></div>
<div class="section">
<h3><a name="Pre-Extracting_Text_from_Binaries"></a><a name="text-extraction"></a>Pre-Extracting Text from Binaries</h3>
<p>Refer to <a href="pre-extract-text.html">pre-extraction via oak-run</a>.</p></div>
<div class="section">
<h3><a name="Advanced_search_features"></a><a name="advanced-search-features"></a>Advanced search features</h3>
<div class="section">
<h4><a name="Suggestions"></a><a name="suggestions"></a>Suggestions</h4>
<p><tt>@since Oak 1.1.17, 1.0.15</tt></p>
<p>In order to use Lucene index to perform search suggestions, the index definition node (the one of type <tt>oak:QueryIndexDefinition</tt>) needs to have the <tt>compatVersion</tt> set to <tt>2</tt>, then one or more property nodes, depending on use case, need to have the property <tt>useInSuggest</tt> set to <tt>true</tt>, such setting controls from which properties terms to be used for suggestions will be taken.</p>
<p>Once the above configuration has been done, by default, the Lucene suggester is updated every 10 minutes but that can be changed by setting the property <tt>suggestUpdateFrequencyMinutes</tt> in <tt>suggestion</tt> node under the index definition node to a different value. <i>Note that up till Oak 1.3.14/1.2.14, <tt>suggestUpdateFrequencyMinutes</tt> was to be setup at index definition node itself. That is is still supported for backward compatibility, but having a separate <tt>suggestion</tt> node is preferred.</i></p>
<p>Sample configuration for suggestions based on terms contained in <tt>jcr:description</tt> property.</p>

<div class="source">
<div class="source"><pre class="prettyprint">/oak:index/lucene-suggest
  - jcr:primaryType = &quot;oak:QueryIndexDefinition&quot;
  - compatVersion = 2
  - type = &quot;lucene&quot;
  - async = &quot;async&quot;
  + suggestion
    - suggestUpdateFrequencyMinutes = 20
  + indexRules
    - jcr:primaryType = &quot;nt:unstructured&quot;
    + nt:base
      + properties
        - jcr:primaryType = &quot;nt:unstructured&quot;
        + jcr:description
          - propertyIndex = true
          - analyzed = true
          - useInSuggest = true
</pre></div></div>
<p><tt>@since Oak 1.3.12, 1.2.14</tt> the index Analyzer can be used to perform a have more fine grained suggestions, e.g. single words (whereas default suggest configuration returns entire property values, see [OAK-3407]: <a class="externalLink" href="https://issues.apache.org/jira/browse/OAK-3407)">https://issues.apache.org/jira/browse/OAK-3407)</a>. Analyzed suggestions can be enabled by setting &#x201c;suggestAnalyzed&#x201d; property to true, e.g.:</p>

<div class="source">
<div class="source"><pre class="prettyprint">/oak:index/lucene-suggest
  - jcr:primaryType = &quot;oak:QueryIndexDefinition&quot;
  - compatVersion = 2
  - type = &quot;lucene&quot;
  - async = &quot;async&quot;
  + suggestion
    - suggestUpdateFrequencyMinutes = 20
    - suggestAnalyzed = true
</pre></div></div>
<p><i>Note that up till Oak 1.3.14/1.2.14, <tt>suggestAnalyzed</tt> was to be setup at index definition node itself. That is is still supported for backward compatibility, but having a separate <tt>suggestion</tt> node is preferred.</i></p>
<p>Setting up <tt>useInSuggest=true</tt> for a property definition having <tt>name=:nodeName</tt> would add node names to suggestion dictionary (See <a href="#property-names">property name</a> for node name indexing)</p>
<p>Since, Oak 1.3.16/1.2.14, very little support exists for queries with <tt>ISDESCENDANTNODE</tt> constraint to subset suggestions on a sub-tree. It requires <tt>evaluatePathRestrictions=true</tt> on index definition. e.g. <tt>
SELECT rep:suggest() FROM [nt:base] WHERE SUGGEST('test') AND ISDESCENDANTNODE('/a/b')
</tt> or <tt>
/jcr:root/a/b//[rep:suggest('in 201')]/(rep:suggest())
</tt> Note, the subset is done by filtering top 10 suggestions. So, it&#x2019;s possible to get no suggestions for a subtree query, if top 10 suggestions are not part of that subtree. For details look at <a class="externalLink" href="https://issues.apache.org/jira/browse/OAK-3994">OAK-3994</a> and related issues.</p></div>
<div class="section">
<h4><a name="Spellchecking"></a><a name="spellchecking"></a>Spellchecking</h4>
<p><tt>@since Oak 1.1.17, 1.0.13</tt></p>
<p>In order to use Lucene index to perform spellchecking, the index definition node (the one of type <tt>oak:QueryIndexDefinition</tt>) needs to have the <tt>compatVersion</tt> set to <tt>2</tt>, then one or more property nodes, depending on use case, need to have the property <tt>useInSpellcheck</tt> set to <tt>true</tt>, such setting controls from which properties terms to be used for spellcheck corrections will be taken.</p>
<p>Sample configuration for spellchecking based on terms contained in <tt>jcr:title</tt> property.</p>
<p>Since Oak 1.3.11/1.2.14, the each suggestion would be returned per row.</p>

<div class="source">
<div class="source"><pre class="prettyprint">/oak:index/lucene-spellcheck
  - jcr:primaryType = &quot;oak:QueryIndexDefinition&quot;
  - compatVersion = 2
  - type = &quot;lucene&quot;
  - async = &quot;async&quot;
  + indexRules
    - jcr:primaryType = &quot;nt:unstructured&quot;
    + nt:base
      + properties
        - jcr:primaryType = &quot;nt:unstructured&quot;
        + jcr:title
          - propertyIndex = true
          - analyzed = true
          - useInSpellcheck = true
</pre></div></div>
<p>Since, Oak 1.3.16/1.2.14, very little support exists for queries with <tt>ISDESCENDANTNODE</tt> constraint to subset suggestions on a sub-tree. It requires <tt>evaluatePathRestrictions=true</tt> on index definition. e.g. <tt>
SELECT rep:suggest() FROM [nt:base] WHERE SUGGEST('test') AND ISDESCENDANTNODE('/a/b')
</tt> or <tt>
/jcr:root/a/b//[rep:suggest('in 201')]/(rep:suggest())
</tt> Note, the subset is done by filtering top 10 spellchecks. So, it&#x2019;s possible to get no results for a subtree query, if top 10 spellchecks are not part of that subtree. For details look at <a class="externalLink" href="https://issues.apache.org/jira/browse/OAK-3994">OAK-3994</a> and related issues.</p></div>
<div class="section">
<h4><a name="Facets"></a><a name="facets"></a>Facets</h4>
<p><tt>@since Oak 1.3.14</tt></p>
<p>Lucene property indexes can also be used for retrieving facets, in order to do so the property <i>facets</i> must be set to  <i>true</i> on the property definition.</p>

<div class="source">
<div class="source"><pre class="prettyprint">/oak:index/lucene-with-facets
  - jcr:primaryType = &quot;oak:QueryIndexDefinition&quot;
  - compatVersion = 2
  - type = &quot;lucene&quot;
  - async = &quot;async&quot;
  + indexRules
    - jcr:primaryType = &quot;nt:unstructured&quot;
    + nt:base
      + properties
        - jcr:primaryType = &quot;nt:unstructured&quot;
        + jcr:title
          - facets = true
          - propertyIndex = true
</pre></div></div>
<p>Specific facet related features for Lucene property index can be configured in a separate <i>facets</i> node below the  index definition.  By default ACL checks are always performed on facets by the Lucene property index however this can be avoided by setting  the property <i>secure</i> to <i>false</i> in the <i>facets</i> configuration node. <tt>@since Oak 1.5.15</tt> The no. of facets to be retrieved is configurable via the <i>topChildren</i> property, which defaults to 10.</p>

<div class="source">
<div class="source"><pre class="prettyprint">/oak:index/lucene-with-unsecure-facets
  - jcr:primaryType = &quot;oak:QueryIndexDefinition&quot;
  - compatVersion = 2
  - type = &quot;lucene&quot;
  - async = &quot;async&quot;
  + facets
    - topChildren = 100
    - secure = false
  + indexRules
    - jcr:primaryType = &quot;nt:unstructured&quot;
    + nt:base
      + properties
        - jcr:primaryType = &quot;nt:unstructured&quot;
        + jcr:title
          - facets = true
          - propertyIndex = true
</pre></div></div></div>
<div class="section">
<h4><a name="Score_Explanation"></a><a name="score-explanation"></a>Score Explanation</h4>
<p><tt>@since Oak 1.3.12</tt></p>
<p>Lucene supports <a class="externalLink" href="https://lucene.apache.org/core/4_6_0/core/org/apache/lucene/search/IndexSearcher.html#explain%28org.apache.lucene.search.Query,%20int%29">explanation of scores</a> which can be selected in a query using a virtual column <tt>oak:scoreExplanation</tt>. e.g. <tt>select [oak:scoreExplanation], * from [nt:base] where foo='bar'</tt></p>
<p><i>Note that showing explanation score is expensive. So, this feature should be used for debug purposes only</i>.</p></div>
<div class="section">
<h4><a name="Custom_hooks"></a><a name="custom-hooks"></a>Custom hooks</h4>
<p><tt>@since Oak 1.3.14</tt></p>
<p>In OSGi enviroment, implementations of <tt>IndexFieldProvider</tt> and <tt>FulltextQueryTermsProvider</tt> under <tt>org.apache.jackrabbit.oak.plugins.index.lucene.spi</tt> (see javadoc <a class="externalLink" href="http://www.javadoc.io/doc/org.apache.jackrabbit/oak-lucene/">here</a>) are called during indexing and querying as documented in javadocs.</p></div></div>
<div class="section">
<h3><a name="Design_Considerations"></a><a name="design-considerations"></a>Design Considerations</h3>
<p>Lucene index provides quite a few features to meet various query requirements. While defining the index definition do consider the following aspects</p>

<ol style="list-style-type: decimal">
  
<li>
<p>If query uses different path restrictions keeping other restrictions same then make use of <tt>evaluatePathRestrictions</tt></p></li>
  
<li>
<p>If query performs sorting then have an explicit property definition for the property on which sorting is being performed and set <tt>ordered</tt> to true for that property</p></li>
  
<li>
<p>If the query is based on specific nodeType then define <tt>indexRules</tt> for that nodeType</p></li>
  
<li>
<p>Aim for a precise index configuration which indexes just the right amount of content based on your query requirement. An index which is precise would be smaller and would perform better.</p></li>
  
<li>
<p><b>Make use of nodetype to achieve a <i>cohesive</i> index</b>. This would allow multiple queries to make use of same index and also evaluation of multiple property restrictions natively in Lucene</p></li>
  
<li>
<p><b><a href="#non-root-index">Non root indexes</a></b> - If your query always perform search under certain paths then create index definition under those paths only. This might be helpful in multi tenant deployment where each tenant data is stored under specific repository path and all queries are made under those path. </p>
<p>In fact its recommended to use single index if all the properties being indexed are related. This would enable Lucene index to evaluate as much property restriction as possible natively (which is faster) and also save on storage cost incurred in storing the node path.</p></li>
  
<li>
<p>Use features when required - There are certain features provided by Lucene index which incur extra cost in terms of storage space when enabled. For example enabling <tt>evaluatePathRestrictions</tt>, <tt>ordering</tt> etc. Enable such option only when you make use of those features and further enable them for only those properties. So <tt>ordering</tt> should be enabled only when sorting is being performed for those properties and <tt>evaluatePathRestrictions</tt> should only be enabled if you are going to specify path restrictions.</p></li>
  
<li>
<p><b>Avoid overlapping index definition</b> - Do not have overlapping index definition indexing same nodetype but having different <tt>includedPaths</tt> and <tt>excludedPaths</tt>. Index selection logic does not make use of the <tt>includedPaths</tt> and <tt>excludedPaths</tt> for index selection. Index selection is done only on cost basis and <tt>queryPaths</tt>. Having multiple definition for same type would cause ambiguity in index selection and may lead to unexpected results. Instead have a single index definition for same type.</p></li>
</ol>
<p>Following analogy might be helpful to people coming from RDBMS world. Treat your nodetype as Table in your DB and all the direct or relative properties as columns in that table. Various property definitions can then be considered as index for those columns. </p></div>
<div class="section">
<h3><a name="Limits"></a><a name="limits"></a>Limits</h3>
<p>The Apache Lucene version currently used in Oak has a limit of about 2^31 documents per index (<a class="externalLink" href="http://lucene.apache.org/core/6_5_0/core/org/apache/lucene/codecs/lucene62/package-summary.html#Limitations">this includes Lucene version 6</a>). If a larger index is needed, please use Apache Solr, which doesn&#x2019;t have this limit.</p></div>
<div class="section">
<h3><a name="Lucene_Index_vs_Property_Index"></a><a name="lucene-vs-property"></a>Lucene Index vs Property Index</h3>
<p>Lucene based index can be restricted to index only specific properties and in that case it is similar to <a href="query.html#property-index">Property Index</a>. However it differs from property index in following aspects</p>

<ol style="list-style-type: decimal">
  
<li>
<p>Lucene index is Asynchronous - Lucene indexing is done asynchronously with a default interval of 5 secs. If there are lots of writes and those writes are related to what is being indexed then it might cause further delay. Compared to this the property index are always synchronous and upto date.</p>
<p>So if in your usecase you need the latest result then prefer <i>Property Indexes</i> over <i>Lucene Index</i>. Oak 1.6 supports <a href="indexing.html#nrt-indexing">Near Realtime Indexing</a> which reduce the lag considerably. With this you should be able to use lucene indexing for most cases</p></li>
  
<li>
<p>Lucene index cannot enforce uniqueness constraint - By virtue of it being asynchronous it cannot enforce uniqueness constraint.</p></li>
</ol></div>
<div class="section">
<h3><a name="Examples"></a><a name="examples"></a>Examples</h3>
<p>Have a look at <a href="#generate-index-definition">generating index definition</a> for some tooling details which simplify generating index definition for given set of queries</p>
<div class="section">
<h4><a name="A_-_Simple_queries"></a><a name="simple-queries"></a>A - Simple queries</h4>
<p>In many cases the query is purely based on some specific property and is not restricted to any specific nodeType</p>

<div class="source">
<div class="source"><pre class="prettyprint">SELECT
  *
FROM [nt:base] AS s
WHERE ISDESCENDANTNODE([/content/public/platform])
AND s.code = 'DRAFT'
</pre></div></div>
<p>Following index definition would allow using Lucene index for above query</p>

<div class="source">
<div class="source"><pre class="prettyprint">/oak:index/assetType
  - jcr:primaryType = &quot;oak:QueryIndexDefinition&quot;
  - compatVersion = 2
  - type = &quot;lucene&quot;
  - async = &quot;async&quot;
  - evaluatePathRestrictions = true
  + indexRules
    - jcr:primaryType = &quot;nt:unstructured&quot;
    + nt:base
      + properties
        - jcr:primaryType = &quot;nt:unstructured&quot;
        + code
          - propertyIndex = true
          - name = &quot;code&quot;
</pre></div></div>
<p>Above definition</p>

<ul>
  
<li>Indexes <tt>code</tt> property present on any node</li>
  
<li>Supports evaluation of path restriction i.e. <tt>ISDESCENDANTNODE([/content/public/platform])</tt>  via <tt>evaluatePathRestrictions</tt></li>
  
<li>Has a single indexRule for <tt>nt:base</tt> as queries do not specify any explicit  nodeType restriction</li>
</ul>
<p>Now you have another query like <tt>
SELECT
  *
FROM [nt:base] AS s
WHERE 
  s.status = 'DONE'
</tt></p>
<p>Here we can either add another property to the above definition or create a new index definition altogether. By default prefer to club such indexes together</p>

<div class="source">
<div class="source"><pre class="prettyprint">/oak:index/assetType
  - jcr:primaryType = &quot;oak:QueryIndexDefinition&quot;
  - compatVersion = 2
  - type = &quot;lucene&quot;
  - async = &quot;async&quot;
  - evaluatePathRestrictions = true
  + indexRules
    - jcr:primaryType = &quot;nt:unstructured&quot;
    + nt:base
      + properties
        - jcr:primaryType = &quot;nt:unstructured&quot;
        + code
          - propertyIndex = true
          - name = &quot;code&quot;
        + status
          - propertyIndex = true
          - name = &quot;status&quot;
</pre></div></div>
<p>Taking another example. Lets say you perform a range query like</p>

<div class="source">
<div class="source"><pre class="prettyprint">SELECT
  [jcr:path],
  [jcr:score],
  *
FROM [nt:base] AS a
WHERE isdescendantnode(a, '/content')
AND [offTime] &gt; CAST('2015-04-06T02:28:33.032-05:00' AS date)
</pre></div></div>
<p>This can also be clubbed in same index definition above</p>

<div class="source">
<div class="source"><pre class="prettyprint">/oak:index/assetType
  - jcr:primaryType = &quot;oak:QueryIndexDefinition&quot;
  - compatVersion = 2
  - type = &quot;lucene&quot;
  - async = &quot;async&quot;
  - evaluatePathRestrictions = true
  + indexRules
    - jcr:primaryType = &quot;nt:unstructured&quot;
    + nt:base
      + properties
        - jcr:primaryType = &quot;nt:unstructured&quot;
        + code
          - propertyIndex = true
          - name = &quot;code&quot;
        + status
          - propertyIndex = true
          - name = &quot;status&quot;
        + offTime
          - propertyIndex = true
          - name = &quot;offTime&quot;
</pre></div></div></div>
<div class="section">
<h4><a name="B_-_Queries_for_structured_content"></a><a name="queries-structured-content"></a>B - Queries for structured content</h4>
<p>Queries in previous examples were based on mostly unstructured content where no nodeType restrictions were applied. However in many cases the nodes being queried confirm to certain structure. For example you have following content</p>

<div class="source">
<div class="source"><pre class="prettyprint">/content/dam/assets/december/banner.png
  - jcr:primaryType = &quot;app:Asset&quot;
  + jcr:content
    - jcr:primaryType = &quot;app:AssetContent&quot;
    + metadata
      - dc:format = &quot;image/png&quot;
      - status = &quot;published&quot;
      - jcr:lastModified = &quot;2009-10-9T21:52:31&quot;
      - app:tags = [&quot;properties:orientation/landscape&quot;, &quot;marketing:interest/product&quot;]
      - size = 450
      - comment = &quot;Image for december launch&quot;
      - jcr:title = &quot;December Banner&quot;
      + xmpMM:History
        + 1
          - softwareAgent = &quot;Adobe Photoshop&quot;
          - author = &quot;David&quot;
    + renditions (nt:folder)
      + original (nt:file)
        + jcr:content
          - jcr:data = ...
</pre></div></div>
<p>Content like above is then queried in multiple ways. So lets take first query</p>
<p><a name="uc1"></a> <b>UC1 - Find all assets which are having <tt>status</tt> as <tt>published</tt></b></p>

<div class="source">
<div class="source"><pre class="prettyprint">SELECT
  *
FROM [app:Asset] AS a
WHERE 
  a.[jcr:content/metadata/status] = 'published'
</pre></div></div>
<p>For this following index definition would be have to be created</p>

<div class="source">
<div class="source"><pre class="prettyprint">/oak:index/assetType
  - jcr:primaryType = &quot;oak:QueryIndexDefinition&quot;
  - compatVersion = 2
  - type = &quot;lucene&quot;
  - async = &quot;async&quot;
  + indexRules
    - jcr:primaryType = &quot;nt:unstructured&quot;
    + app:Asset
      + properties
        - jcr:primaryType = &quot;nt:unstructured&quot;
        + status
          - propertyIndex = true
          - name = &quot;jcr:content/metadata/status&quot;
</pre></div></div>
<p>Above index definition</p>

<ul>
  
<li>Indexes all nodes of type <tt>app:Asset</tt> <b>only</b></li>
  
<li>Indexes relative property <tt>jcr:content/metadata/status</tt> for all such nodes</li>
</ul>
<p><a name="uc2"></a> <b>UC2 - Find all assets which are having <tt>status</tt> as <tt>published</tt> sorted by last modified date</b></p>

<div class="source">
<div class="source"><pre class="prettyprint">SELECT
  *
FROM [app:Asset] AS a
WHERE 
  a.[jcr:content/metadata/status] = 'published'
ORDER BY
  a.[jcr:content/metadata/jcr:lastModified] DESC
</pre></div></div>
<p>To enable above query the index definition needs to be updated to following</p>

<div class="source">
<div class="source"><pre class="prettyprint">    + app:Asset
      + properties
        - jcr:primaryType = &quot;nt:unstructured&quot;
        + status
          - propertyIndex = true
          - name = &quot;jcr:content/metadata/status&quot;        
        + lastModified
          - propertyIndex = true
          - name = &quot;jcr:content/metadata/jcr:lastModified&quot;
          - ordered = true
          - type = Date
</pre></div></div>
<p>Above index definition</p>

<ul>
  
<li><tt>jcr:content/metadata/jcr:lastModified</tt> is marked as <b><tt>ordered</tt></b> enabling  support <i>order by</i> evaluation i.e. sorting for such properties</li>
  
<li>Property type is set to <tt>Date</tt></li>
  
<li>Indexes both <tt>status</tt> and <tt>jcr:lastModified</tt></li>
</ul>
<p><a name="uc3"></a> <b>UC3 - Find all assets where comment contains <i>december</i></b></p>

<div class="source">
<div class="source"><pre class="prettyprint">SELECT
  *
FROM [app:Asset] 
WHERE 
  CONTAINS([jcr:content/metadata/comment], 'december')
</pre></div></div>
<p>To enable above query the index definition needs to be updated to following</p>

<div class="source">
<div class="source"><pre class="prettyprint">    + app:Asset
      + properties
        - jcr:primaryType = &quot;nt:unstructured&quot;
        + comment
          - name = &quot;jcr:content/metadata/comment&quot;
          - analyzed = true
</pre></div></div>
<p>Above index definition</p>

<ul>
  
<li><tt>jcr:content/metadata/comment</tt> is marked as <b><tt>analyzed</tt></b> enabling  evaluation of <tt>contains</tt> i.e. fulltext search</li>
  
<li><tt>propertyIndex</tt> is not enabled as this property is not going to be used to  perform equality check</li>
</ul>
<p><a name="uc4"></a> <b>UC4 - Find all assets which are created by David and refer to december </b></p>

<div class="source">
<div class="source"><pre class="prettyprint">SELECT
  *
FROM [app:Asset] 
WHERE 
  CONTAINS(., 'december david')
</pre></div></div>
<p>Here we want to create a fulltext index for all assets. It would index all the properties in <tt>app:Asset</tt> including all relative nodes. To enable that we need to make use of <a href="#aggregation">aggregation</a></p>

<div class="source">
<div class="source"><pre class="prettyprint">/oak:index/assetType
  - jcr:primaryType = &quot;oak:QueryIndexDefinition&quot;
  - compatVersion = 2
  - type = &quot;lucene&quot;
  - async = &quot;async&quot;
  + aggregates
    + app:Asset
      + include0
        - path = &quot;jcr:content&quot;
      + include1
        - path = &quot;jcr:content/metadata&quot;      
      + include2
        - path = &quot;jcr:content/metadata/*&quot;
      + include3
        - path = &quot;jcr:content/metadata/*/*&quot;        
      + include4
        - path = &quot;jcr:content/renditions&quot;
      + include5
        - path = &quot;jcr:content/renditions/original&quot; 
    + nt:file
      + include0
        - path = &quot;jcr:content&quot;
  + indexRules
    - jcr:primaryType = &quot;nt:unstructured&quot;
    + app:Asset
      - includePropertyTypes = [&quot;String&quot;, &quot;Binary&quot;]
      + properties
        - jcr:primaryType = &quot;nt:unstructured&quot;
        + comment
          - propertyIndex = true
          - nodeScopeIndex = true
          - name = &quot;jcr:content/metadata/comment&quot;
</pre></div></div>
<p>Above index definition</p>

<ul>
  
<li>
<p>Only indexes <tt>String</tt> and <tt>Binary</tt> properties as part of fulltext index via <b><tt>includePropertyTypes</tt></b></p></li>
  
<li>
<p>Has <tt>aggregates</tt> defined for various relative paths like <i>jcr:content</i>, <i>jcr:content/metadata</i>, <i>jcr:content/renditions/original</i> etc. </p>
<p>With these rules properties like <i>banner.png/metadata/comment</i>, <i>banner.png/metadata/xmpMM:History/1/author</i> get indexed as part for fulltext index for <i>banner.png</i> node.</p></li>
  
<li>
<p>Inclusion of <i>jcr:content/renditions/original</i> would lead to aggregation of <i>jcr:content/renditions/original/jcr:content/jcr:data</i> property also as aggregation logic would apply rules for <tt>nt:file</tt> while aggregating the <tt>original</tt> node</p></li>
  
<li>
<p>Aggregation would include by default all properties which are part of <b><tt>includePropertyTypes</tt></b>. However if any property has a explicit property definition provided like <tt>comment</tt> then <tt>nodeScopeIndex</tt> would need to be set to true</p></li>
</ul>
<p>Above definition would allow fulltext query to be performed. But we can do more. Suppose you want to give more preference to those nodes where the fulltext term is found in <tt>jcr:title</tt> compared to any other field. In such cases we can <tt>boost</tt> such fields </p>

<div class="source">
<div class="source"><pre class="prettyprint">  + indexRules
    - jcr:primaryType = &quot;nt:unstructured&quot;
    + app:Asset
      + properties
        - jcr:primaryType = &quot;nt:unstructured&quot;
        + comment
          - propertyIndex = true
          - nodeScopeIndex = true
          - name = &quot;jcr:content/metadata/comment&quot;
        + title
          - propertyIndex = true
          - nodeScopeIndex = true
          - name = &quot;jcr:content/metadata/jcr:title&quot;
          - boost = 2.0
</pre></div></div></div></div></div>
        </div>
      </div>
    </div>
    <hr/>
    <footer>
      <div class="container-fluid">
        <div class="row-fluid">
            <p>Copyright &copy;2012&#x2013;2018
<a href="https://www.apache.org/">The Apache Software Foundation</a>.
All rights reserved.</p>
        </div>
                          <div id="ohloh" class="pull-right">
      <script type="text/javascript" src="https://www.ohloh.net/p/jackrabbit-oak/widgets/project_thin_badge.js"></script>
    </div>
        </div>
    </footer>
    </body>
</html>
